{"pages":[{"title":"About Me","text":"My name is Kyson Lok. I am a software engineer. I’m keen to learn, experience and share. My interests include, but are not limited to: Deep Learning Computer Vision Neural Network Internet of Things(IoT) Computer Security and Cryptography and more… The aim of this web page is to organize and share my works from research, lectures, and projects. Anyone is welcome to use and contribute to materials exhibited in this page.","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"Gitee搭建个人图床","text":"写在前面利用 PicGo 工具把本地图片上传到 Gitee，来实现个人图床。选择 Gitee 的原因是因为在国内访问 Gitee 较快，访问 GitHub 是蜗牛的速度。PicGo 默认不支持 Gitee 作为图床，要安装 gitee-uploader 插件。 安装 下载并安装 PicGo； 下载并安装 node.js； 打开 PicGo，在【插件设置】搜索并安装 gitee-uploader插件。 配置图床在 PicGo 的【图床设置】- 【gitee】设置图床的配置，配置之前要在 Gitee 上新建一个用于存放图床的仓库，配置如下： repo：Gitee 上的仓库链接 branch：仓库的分支 token：Gitee 的私人令牌，点击头像 -【设置】-【私人令牌】，再点击生成新令牌，验证密码之后会生成一个 token，把 token 复制到配置中 注意，令牌只会明文显示一次，建议在配置插件的时候再来生成令牌，直接复制进去，忘记了要重新生成。 path：可选项，指定图片上传到 Gitee 仓库的哪个目录 customPath 和 customUrl：提交的 message，保持默认就好 点击设为默认图床完成配置，回到上传区就可以使用了。 配置 PicGoPicGo 默认不对上传图片进行修改，我一般不关心图片的命名，因此设置 PicGo 在上传之前使用时间戳重命名图片。 点击 PicGo设置 ，开启 上传前重命名 和 时间戳重命名。","link":"/2020/06/07/Gitee%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/"},{"title":"Hexo Icarus 支持Latex数学公式","text":"支持 MathJaxIcarus 主题默认支持了 MathJax 插件渲染数学公式，只需要在主题配置文件 theme/icarus/_config.yml 使能就可以直接使用。 关于更多说明，可以参考 icarus-user-guide-other-plugins-MathJax。 要注意的地方是，如果使用了多个配置文件，如默认配置使用 theme/icarus/_config.yml，文章页面配置使用 theme/icarus/_config.yml，则需要在文章页面配置 theme/icarus/_config.yml 里面使能 MathJax。 语法渲染错误由于 Latex 和 Markdown 有些语法会冲突，如下划线 _，在 Markdown 被渲染成斜体。有两种解决办法： 使用转义字符 \\： 123$$\\hat{x}_{k}=\\hat{x}_{k}^{-}+K_{t}\\left(y_{k}\\right)$$ 使用 HTML 标签，内联表达式用 &lt;span&gt;&lt;/span&gt;，块表达式用 &lt;div&gt;&lt;/div&gt;： 12345&lt;div&gt;$$\\hat{x}_{k}=\\hat{x}_{k}^{-}+K_{t}\\left(y_{k}\\right)$$&lt;/div&gt; 预览效果1234567891011121314151617This is inline expression: $ax^2+bx+c&gt;0$.This is a block expression:$$\\displaystyle \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} = 1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}} {1+\\frac{e^{-8\\pi}} {1+\\cdots} } } }$$Or use $LaTeX$ environment: &lt;div&gt;\\begin{equation}A =\\begin{bmatrix} a &amp; b \\\\ c &amp; c\\end{bmatrix}\\end{equation}&lt;/div&gt; This is another inline expression: $ax^2+bx+c&gt;0$. This is a block expression: $$\\displaystyle \\frac{1}{\\Bigl(\\sqrt{\\phi \\sqrt{5}}-\\phi\\Bigr) e^{\\frac25 \\pi}} =1+\\frac{e^{-2\\pi}} {1+\\frac{e^{-4\\pi}} {1+\\frac{e^{-6\\pi}}{1+\\frac{e^{-8\\pi}} {1+\\cdots} } } }$$ use $LaTeX$ environment: \\begin{equation} A = \\begin{bmatrix} a & b \\\\ c & c \\end{bmatrix} \\end{equation}","link":"/2020/06/11/Hexo-Icarus-%E6%94%AF%E6%8C%81Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"},{"title":"Hexo NextT 主题设置","text":"安装和开始按照 Hexo 官方文档的指导安装 Hexo，并且使用 hexo init 创建一个博客站点。 切换到博客根目录，下载 NextT 主题： 1git clone https://github.com/theme-next/hexo-theme-next themes/next 版本说明hexo 版本: 4.2.0next 版本: 7.8.0 注意时效性，版本不同配置项可能存在差异。 NextT 主题配置基础配置使用 NextT 主题，并且设置语言为中文，修改博客根目录下的 _config.yml 文件： 12language: zh-CN theme: next 接着修改主题风格，在 theme 配置 themes/next/_config.yml 文件找到 scheme 字段，选择主题风格。目前支持四种：Muse, Mist, Pisces 和 Gemini，任意选择一种合适的，我这里用的是 Mist 方案。 设置菜单在 theme 配置 themes/next/_config.yml 文件找到 menu 字段，可以根据个人偏好设置菜单。我这里保留了分类 categories，标签 tags，归档 archives 和 关于 about，|| 后面表示图标，这里不作修改。 123456789menu: home: / || fa fa-home categories: /categories/ || fa fa-th tags: /tags/ || fa fa-tags archives: /archives/ || fa fa-archive about: /about/ || fa fa-user #schedule: /schedule/ || fa fa-calendar #sitemap: /sitemap.xml || fa fa-sitemap #commonweal: /404/ || fa fa-heartbeat 创建页面设置完菜单，由于新增的菜单栏没有对应的页面，点击会提示找不到页面，执行以下命令为新增的菜单栏添加对应的页面： 123hexo new page tagshexo new page categorieshexo new page about 成功执行以上命令，在 sources 目录下会生成对应的文件夹，每个文件夹里包含一个 index.md 文件。 文章显示默认首页的文章会显示全文，可以在原文插入 &lt;!-- more --&gt; 标签，会自动把该标签前面的文本生成摘要显示。 123Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.&lt;!-- more --&gt;Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. 显示头像和 favicon在 theme 配置 themes/next/_config.yml 文件找到 avatar 字段，设置 url 为头像文件(头像放置的路径为 themes/next/source/images) 。我比较喜欢头像呈圆形，这里把 rounded 的值改为了 true。 12345678avatar: # Replace the default image and set the url here. # url: #/images/avatar.gif url: /images/avatar.png # If true, the avatar will be dispalyed in circle. rounded: true # If true, the avatar will be rotated with the cursor. rotated: false 可以使用 favicon-generator 网站制作 favicon，制作完之后下载，把制作好的 favicon 放置到 themes/next/source/images 目录下，在 theme 配置 themes/next/_config.yml 文件找到 favicon 字段，把相应的文件名改成上传的新 favicon 文件名。 1234567favicon: small: /images/favicon-16x16.png medium: /images/favicon-32x32.png apple_touch_icon: /images/apple-touch-icon.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml 搜索功能在 theme 配置 themes/next/_config.yml 文件找到 local_search 字段，把值改为 true。并且在博客根目录下的_config.yml 文件添加以下内容： 12345search: path: search.xml field: post format: html limit: 10000 注意，搜索功能依赖 https://github.com/theme-next/hexo-generator-searchdb，在博客根目录执行 npm install hexo-generator-searchdb --save 进行安装。 加载进度条在 theme 配置 themes/next/_config.yml 文件找到 pace 字段，把值改为 true，根据个人偏好选择任意一种提供的样式填入 pace_theme。 注意，进度条依赖 https://github.com/theme-next/theme-next-pace，按照 theme-next-pace 的 README 说明进行安装。 Fork me on GitHub在 github-corners 或者 github-ribbons 选择自己喜欢的样式，复制插入到 themes/next/layout/_layout.swig 文件中 &lt;div class=&quot;headband&quot;&gt;&lt;/div&gt; 位置后面。 12&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;&lt;a href=&quot;https://github.com/kysonlok&quot;&gt;......","link":"/2020/06/03/Hexo-NextT-%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE/"},{"title":"Hexo Icarus 主题设置","text":"安装和开始按照 Hexo 官方文档的指导安装 Hexo，并且使用 hexo init 创建一个博客站点。 切换到博客根目录，下载 NextT 主题并安装依赖模块： 12git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarusnpm install bulma-stylus@0.8.0 hexo-component-inferno hexo-renderer-inferno inferno inferno-create-element --save 版本说明Hexo 版本: 4.2.0Icarus 版本: 3.1.0 注意时效性，版本不同配置项可能存在差异。 Icarus 主题配置基础配置使用 Icarus 主题，并且设置语言为中文，修改博客根目录下的 _config.yml 文件： 12language: zh-CN theme: icarus Icarus 为我们预置了多达 12 种语言，默认是英文。zh-CN 是简体中文，大家可以根据自己的文案风格修改 theme/icarus/languages/zh-CN.yml 文件。 主题配置首次在博客根目录执行 hexo clean 或者 hexo g 都会触发 Icarus 自动生成一个 theme/icarus/_config.yml 文件。 logo 设置logo 会展示在顶部导航栏的最左侧以及底部的 footer 区域，大家可以替换 source/images/ 下的 logo 文件，使用 svg 或者 png 格式的都可以。 评论系统Icarus 预置了 Changyan, Disqus, Facebook, Gitment, Gitalk, Isso, LiveRe 和 Valine 八大主流评论插件。 这里以我使用的 Valine 为例。首先在 LeanCloud 注册一个免费的开发账号，新建一个新应用，并把 appid 和 appkey 配置在对应部分： 123456789101112131415161718comment: type: valine app_id: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx app_key: xxxxxxxxxxxxxxxxxxxxxx placeholder: &quot;&quot; # 可选填 avatar: mm # 可选填 avatar_force: false # 可选填 meta: [&quot;nick&quot;, &quot;mail&quot;, &quot;link&quot;] # 可选填 page_size: 10 # 可选填 lang: zh-CN # 可选填 visitor: false # 可选填 highlight: true # 可选填 record_ip: false # 可选填 server_urls: # 可选填 emoji_cdn: # 可选填 emoji_maps: # 可选填 enable_qq: false # 可选填 required_fields: [] # 可选填 其他的评论插件配置，具体可以参见用户评论插件。 如果有的文章不希望别人评论，但是我们又不希望把整个站点的评论关闭的话，可以对指定文章进行评论关闭操作。操作也很简单，只需要在文章 markdown 文件的 front-matter 区域设置 comments 为 false 即可： 1234---title: article titlecomments: false--- 打赏功能Icarus 提供了支付宝，微信，PayPal 和 Patreon 四种支付方式： 12345678910111213141516171819202122232425262728donates: # Alipay donate button configurations - type: alipay # Alipay qrcode image URL qrcode: /img/alipay.jpg # &quot;Buy me a coffee&quot; donate button configurations # - # type: buymeacoffee # URL to the &quot;Buy me a coffee&quot; page # url: '' # Patreon donate button configurations # - # type: patreon # URL to the Patreon page # url: '' # Paypal donate button configurations # - # type: paypal # Paypal business ID or email address # business: '' # Currency code # currency_code: USD # Wechat donate button configurations - type: wechat # Wechat qrcode image URL qrcode: /img/wechat.jpg 支付宝和微信只需要提供二维码就可以了，可以使用本地静态资源或者图床链接。 widget 挂件挂件是 Icarus 比较精髓的部分，所有的 widget 都是一个卡片，可以自由摆放在任何位置。包括文章在内，个人资料、链接、分类、最新文章、归档、标签都是一个卡片，可以在 theme/icarus/_config.yml 中设置各个卡片的具体属性，同时也可以设置卡片出现在网站的左侧还是右侧。 除了在 themes/icarus/_config.yml 的默认主题配置文件外，Icarus 也会从themes/icarus/_config.post.yml 和 themes/icarus/_config.page.yml 获取替代配置。可以在_config.post.yml 中设置仅对所有文章生效的配置， 例如，在此配置文件中把所有的挂件放置在页面一侧来实现所有文章两栏布局，同时其他页面仍保持三栏布局。详细使用可以参见 icarus用户指南-主题配置-配置文件与优先级。 一般文章是 post layout，about/categories/tags 这些是 page layout。 为了页面简洁大方，主页删除了大部分不需要的挂件，左侧只保留个人资料，右侧保留标签、分类和归档。文章页面只保留目录。 themes/icarus/_config.yml 挂件配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051widgets: # Profile widget configurations - # Where should the widget be placed, left sidebar or right sidebar position: left type: profile # Author name author: Kyson Lok # Author title author_title: Developer # Author's current location location: ShenZhen, China # URL or path to the avatar image avatar: /img/avatar.png # Whether show the rounded avatar image avatar_rounded: true # Email address for the Gravatar gravatar: # URL or path for the follow button follow_link: 'https://github.com/kysonlok' # Links to be shown on the bottom of the profile widget social_links: Github: icon: fab fa-github url: 'https://github.com/kysonlok' Facebook: icon: fab fa-facebook url: 'https://facebook.com' Twitter: icon: fab fa-twitter url: 'https://twitter.com' Dribbble: icon: fab fa-dribbble url: 'https://dribbble.com' # RSS: # icon: fas fa-rss # url: / - # Where should the widget be placed, left sidebar or right sidebar position: right type: tags # Categories widget configurations - # Where should the widget be placed, left sidebar or right sidebar position: right type: categories # Archives widget configurations - # Where should the widget be placed, left sidebar or right sidebar position: right type: archives themes/icarus/_config.post.yml 挂件配置： 12345widgets: - # Where should the widget be placed, left sidebar or right sidebar position: right type: toc themes/icarus/_config.page.yml 配置跟 themes/icarus/_config.post.yml 保持一致。","link":"/2020/06/05/Hexo-Icarus-%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE/"},{"title":"费斯妥密码","text":"Feistel 概述Feistel（费斯妥）密码结构，在密码学研究中，Feistel 密码结构是用于分组密码中的一种对称结构，它本身并不是分组密码算法的具体方案，而是一种设计模型。 很多对称分组加密算法都是基于 Feistel 分组密码结构的，其中包括 DES。Feistel 结构是由许多相同的轮函数组成，每轮使用不同的子密钥，每轮包含了代替和置换两个步骤。 构造细节令 F 为轮函数；令 $K_1, K_2, …, K_n$ 分别为第 1, 2, …, n 轮的子密钥。 加密明文过程 将明文块拆分为两个等长的块：($L_0, R_0$)； 在每一轮中，右半部分 $R_i$ 保持不变，作为左半部分下一轮 $L_{i+1}$ 的输入；而左半部分 $L_i$ 经过一个依赖右半部分 $R_i$ 和 子密钥 $K_i$ 的运算，作为右半部分下一轮 $R_{i+1}$ 的输入。 运算的规则为，我们使用一个加密函数 F，它接受两个输入——密钥 K 和 R，该函数的输出为 F(R, K)，然后将左半部分 $L_i$ 和加密函数结果进行异或计算，得到的结果为 $R_{i+1}$。 $$ L_{i+1} = R_i\\\\ R_{i+1} = L_i{\\oplus}F(R_i, K_i) $$ 依次进行 n 轮计算，当最后一轮完成后，两个子块 $R_{n+1}$ 和 $L_{n+1}$ 按顺序连接起来，形成密文块($R_{n+1}, L_{n+1}$)。 解密密文过程 对于密文($R_{n+1}, L_{n+1}$)，通过计算 i = n, n-1, ……, 0，对密文进行加密的逆向操作； 在每一轮中，进行如下运算（i 为当前轮数） $$ R_i = L_{i+1}\\\\ L_i = R_{i+1}{\\oplus}F(L_{i+1}, K_i) $$ 依次进行 n 轮计算，结果($R_0, L_0$)就是明文。 置换与代替置换步骤是指修改过的 L 和未修改过的 R 进行了交换。$L_i$ 经过运算变成了 $R_{i+1}$，$R_i$ 变成了 $L_{i+1}$。 代替步骤是指每个明文元素或元素组被唯一地替换为相应的密文元素或元素组。 影响因素影响Feistel 结构的因素有如下 5 个： 块的大小：大的块会提高加密的安全性，但是会降低加密、解密的速度。截止至2013年，比较流行的这种方案是 64 bit。而 128 bit 的使用也比较广泛。 密钥的大小：同上。现在流行的是 64 bit ，而 128 bit 正逐渐成为主流。 迭代轮数：Feistel 密码的轮数量取决于系统所需的安全性，轮数越多系统越安全。但更多的轮数意味着加密和解密过程增多，效率越低。现阶段比较流行的是 16 轮。 子密钥的生成算法：生成算法越复杂，则会使得密码被破译的难度增强，即，信息会越安全。 轮函数的复杂度：轮函数越复杂，则安全性越高。","link":"/2020/06/10/%E8%B4%B9%E6%96%AF%E5%A6%A5%E5%AF%86%E7%A0%81/"},{"title":"VSCode配置","text":"写在前面工欲善其事，必先利其器。好的开发工具，能大大地提高开发的效率。以前一直使用 VIM 写代码，用 Source Insight 看代码，后来在朋友的推荐下切换到 VSCode，使用了一段时间，发现 VSCode 真的超级强大好用，而且是开源的，不得不让人青睐。写篇文章记录一下 VSCode 的配置以及插件，以便后续重新搭建环境可以作为参考。 安装进入官网 https://code.visualstudio.com/ 下载并安装。 集成 cmdercmder 也是一款非常优秀的开源 Windows 终端模拟器，完全可以代替 Windows 自带的 cmd 工具，可以在 cmder 官网下载。 通过快捷键 Ctrl + Shift + P 打开 VSCode 的命令面板，搜索”open settings”，修改 VSCode 的配置文件。 在 json 配置文件中添加以下内容： 12345678&quot;terminal.integrated.shell.windows&quot;: &quot;cmd.exe&quot;,&quot;terminal.integrated.env.windows&quot;: { &quot;CMDER_ROOT&quot;: &quot;$cmder_root_path&quot;},&quot;terminal.integrated.shellArgs.windows&quot;: [ &quot;/k&quot;, &quot;$cmder_root_path/vendor/init.bat&quot;] 将 $cmder_root_path 替换成 cmder 所在的根路径，注意左反斜杠路径要加转义，即 \\\\，或者直接使用右反斜杠 /，与 Linux 风格保持一致。路径不能包含空格，否则无法正常工作。 重启 VSCode 生效，按 Ctrl + ` 快捷键，就能在 VSCode 中的命令行窗口打开 cmder。 WSL 远程WSL(Windows Subsystem for Linux) 是一款在 Windows10 系统下的 Linux 子系统，就是能在直接在 Windows10 上跑 Linux，不需要安装虚拟机。具体可以参考微软关于 WSL 安装的文档。 开发一般用到 Linux 环境，但是开启虚拟机电脑又会变卡，选择 WSL 是很好的解决方案，主要的优势就是快，而且方便。 VSCode 可以直接远程到 WSL，直接操作 WSL 的目录以及文件。需要安装 Remote - WSL 插件，在插件页面搜索安装即可。安装完成之后，按 Ctrl + Shift + P 快捷键打开命令面板，选择 Remote-WSL: New Window 就能远程到 WSL。 注意，WSL 远程的插件与本地插件是不能共用的，如果需要用到其他插件，要在插件页面安装到 WSL 上。 SSH 远程WSL 基本能满足大部分的场景，但是特殊情况，比如嵌入式开发，用到交叉编译工具编译，WSL 是不支持交叉编译的。对于这种情况，我们会选择虚拟机或者服务器，以服务器为例，一般是没有图像界面的，VSCode 的 SSH 远程插件能远程到服务器，直接操作服务器下的目录以及文件。需要安装 Remote - SSH 插件，在插件页面搜索安装即可，跟 Remote - WSL 类似。 需要说明的是，SSH 每次都要输入密码比较麻烦，可以使用公私钥免密码登录。 首先，在 cmder 执行命令 ssh-keygen 生成公私钥对，提示输入密码时不设置密码，也就是直接回车。 其次，用编辑器打开公钥文件 id_rsa.pub，复制全部内容。 接着，ssh 远程登录到服务器，把公钥文件的内容粘贴到 ~/.ssh/authorized_keys 文件中。 最后，用 VSCode 远程到服务器，按 Ctrl + Shift + P 快捷键打开命令面板，选择 Remote-SSH: Connect to Host，在弹出的 ssh 连接框输入 ssh -i [私钥的绝对路径] yourname@remote_host。 再次选择 Remote-SSH: Connect to Host 就可以看到刚才添加的远程主机。 第一次连接 VSCode 可能不能自动检测到远程的系统类型，会弹框让我们手动选择，选择正确的系统类型，就能开始使用了，就像在本地使用 VSCode 那样，非常方便。 注意，远程主机的插件与本地插件是不能共用的，如果需要用到其他插件，要在插件页面安装到远程主机上。 Markdown 预览增强VSCode 默认支持 Markdown 预览，快捷键是 Ctrl + Shift + V，或者在命令面板面板运行 Markdown: Open Preview to the Side。 但是自带的 Markdown 功能不是很强大，不支持 Latex 数学公式渲染，可以安装 Markdown Preview Enhanced 插件增强 Markdown 预览功能。 C/C++ 开发一般开发环境是 Linux，这里使用 VSCode ssh 远程到 Linux 目标主机的模式。远程到目标主机后，安装 C/C++ 插件，并且在目标主机上安装 gcc 和 make 等开发工具。 12sudo apt-get updatesudo apt-get install build-essential gdb make 打开一个 C/C++ 工程，或者新创建一个工程，用 Makefile 构建好编译规则，配置 VSCode。 编译配置在菜单栏选择 Terminal &gt; Configure Default Build Task，下拉列表显示 c++ 编译器的各种预定义构建任务，选择 C/C++: g++ build active file，会自动在工程目录下生成 .code/tasks.json 配置文件。参考以下内容修改 tasks.json 配置： 1234567891011121314151617181920212223242526{ // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ { &quot;type&quot;: &quot;shell&quot;, &quot;label&quot;: &quot;Make Project&quot;, &quot;command&quot;: &quot;/usr/bin/make&quot;, &quot;args&quot;: [ &quot;-C&quot;, &quot;${fileDirname}&quot; ], &quot;options&quot;: { &quot;cwd&quot;: &quot;/usr/bin&quot; }, &quot;problemMatcher&quot;: [ &quot;$gcc&quot; ], &quot;group&quot;: { &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true } } ]} 调试配置在菜单栏选择 Run &gt; Add Configuration…，下拉列表显示 gdb 调试器的各种预定义构建任务，选择 C++ (GDB/LLDB)，会自动在工程目录下生成 .code/launch.json 配置文件。参考以下内容修改 launch.json 配置： 1234567891011121314151617181920212223242526272829{ // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;gcc build and debug active file&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;${fileDirname}/${fileBasenameNoExtension}&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;${workspaceFolder}&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;setupCommands&quot;: [ { &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true } ], &quot;preLaunchTask&quot;: &quot;Make Project&quot;, &quot;miDebuggerPath&quot;: &quot;/usr/bin/gdb&quot; } ]} preLaunchTask 填的是 tasks.json 的 label 值，表示在调试之前先执行编译任务。 更详细的指南，参考 VSCode 官方文档 GCC on Linux 和 Debug C++ in Visual Studio Code。 快捷键冲突Ctrl + `: 是 VSCode 打开命令行终端的快捷键，该快捷键会跟 cmder 的快捷键冲突，修改 cmder 的快捷键。 Ctrl + Shift + F: 是 VSCode 打开搜索面板的快捷键，该快捷键会跟搜狗输入法的快捷键冲突，修改搜狗输入法的快捷键。 Ctrl + Shift + P: 是 VSCode 打开命令面板的快捷键，该快捷键会跟 PicGo 图床工具的快捷键冲突，将其关闭。","link":"/2020/06/11/VSCode%E5%BC%80%E5%8F%91%E5%88%A9%E5%99%A8/"},{"title":"数据加密标准-DES","text":"DES 加密概述数据加密标准（Data Encryption Standard，缩写为 DES）是由国家标准局（NIST）出版的对称密钥分组密码（块密码）。 对于任何加密体制，总有明文和密钥两个输入。DES 是费斯妥密码（Feistel Cipher）的一种实现，进行 16 轮迭代，其明文长度为 64 bit，密钥长度也是 64 bit（但只有 56 bit 被实际用于算法，其余 8 bit 可以被用于奇偶校验，并在算法中被丢弃）。 DES 的一般结构如下图所示，可见明文的处理经过了三个阶段。 首先，64 bit 明文经过初始置换(IP)而被重新排序； 然后，经过 16 轮相同的费斯妥函数的处理过程，每轮包含了代替和置换两个步骤； 最后， 再进行一次与初始置换互逆的置换($IP^{-1}$) ，得到 64 bit的密文。 除了初始和末尾的置换，DES 的结构与费斯妥密码结构完全相同。 算法描述初始置换和末尾置换初始置换和末尾置换只是对输入按位重新组合，在 DES 中没有密码学意义，初始置换和末尾置换如下所示： 输入的第 58 位换到第 1 位，第 50 位换到第 2 位，…，依此类推，最后一位是原来的第 7 位。假设输入的 64 位块为 $M_1, M_2, M_3, …, M_{64}$，则经过初始置换后的结果为 $M_{58}, M_{50}, M_{42}, …, M_7$。 64 位的输入 M： 这里 $M_i$ 都是二进制，经过置换 X=IP(M) 之后，得到的 X： 费斯妥函数（F 函数）DES 加密的核心是费斯妥函数，即每轮的变换。由费斯妥密码结构可知，明文会被均分成两等分，右半部分和密钥经过费斯妥函数处理。对于 DES 加密，48 bit 子密钥（由主密钥派生）和 32 bit 右半块作为费斯妥函数的输入，处理后输出 32 bit结果。 下图是费斯妥函数的内部结构。密钥 $K_i$ 长度为 48 bit，R 长度为 32 bit。分为四个步骤： 将 R 置换扩展为 48 bit，其中有 16 bit 是重复； 置换扩展产生的 48 bit 输出与 48 bit 的 $K_i$ 异或； 异或的结果经过“S盒”（置换盒），产生 32 bit 的输出； “S盒”的输出最后再经过一次 P 置换，得到的 32 bit 是费斯妥函数的输出。 扩展置换因为右半块长度是 32 bit，而密钥长度是 48 bit，因此，需要先把右半块扩展到 48 bit，称为“扩展置换”。扩展置换是将输入的 32 bit 半块分成 8 个 4 bit 小块，每 4 bit 块加上左右相邻块中紧邻的位，得到 6 bit 输出。第 1 块没有左邻，用第 32 位，最后一块没有右邻，用第 1 位。扩展置换输出 8 个 6 bit 的块，其逻辑如下： 扩展置换逻辑通常被描述为下图的 DES 规范表格： 与密钥混合用异或操作将扩展的 48 bit 右半块和一个 48 bit 子密钥进行混合。16 轮变换使用 16 个 48 bit 子密钥，也就是每轮用的子密钥都是不同的，48 bit 的子密钥是利用密钥调度（下面介绍）从 58 bit 主密钥生成。 S 盒（置换盒）48 bit 的异或输出再经过 S 盒处理，产生 32 bit 的输出。S 盒执行真正的混淆，它提供了 DES 的核心安全性。如果没有 S 盒，密码会是线性的，很容易破解。DES 使用 8 个 S 盒，每个盒子以查找表方式提供非线性的变换，将 6 bit 输入变成 4 bit 输出。 S 盒是一个 4x16 的表，盒 $S_i$ 输入的 6 bit 中，由第 1 位和第 6 位组成的二进制数确定表的行，中间 4 位组成的二进制数确定表的列，行和列交叉的元素转换成 4 bit 二进制数作为输出。 DES 的 8 个 S 盒变换表（下标从 0 开始）规格如图所示： 例如，在 $S_1$ 中，若输入为 011001，则行是 1(01)，列是 12(1100)，由行和列确定的元素是 9(1, 12)，9 对应的二进制为 1001，因此 4 bit 输出为 1001。 置换S 盒的 32 bit 输出最后再经过一次“P置换”进行重组。这个设计是为了将每个 S 盒的 4 位输出在下一回次的扩张后，使用 4 个不同的 S 盒进行处理。置换表格如下图所示： S 盒，P 置换和 E 扩展各自满足了克劳德·香农在 1940 年代提出的实用密码所需的必要条件——“混淆与扩散”。 密钥生成前面我们知道，密钥长度为 64 bit，算法只用 56 bit。循环密钥生成器从 56 bit 密钥中创建 16 个 48 bit 子密钥。密钥生成过程如下图所示。 首先，使用选择置换 1(PC-1) 从 64 bit 输入密钥中选出 56 bit 的密钥，剩余的 8 bit 要么直接被丢弃掉，要么作为奇偶校验位。 然后，将 56 bit 密钥分成两个 28 bit 的半密钥。在接下来的每轮变换中，两个半密钥都被左移 1 或 2 位（左移 1 还是 2 由当前的迭代轮数决定），移位后的值作为下一轮的输入，并且通过选择置换 2(PC-2) 压缩成 48 bit 的子密钥。 解密过程中，除了子密钥输出的顺序相反外，密钥调度的过程与加密完全相同。 置换选择以及移位次数如下图所示： 安全与密码分析DES 满足分组密码的两个要求，这两个特性使加密非常强大。 雪崩效应——明文或密钥的微小改变将对密文产生很大的影响。 完备性——每一位密文都依赖于许多位明文。 到当前为止，最实用的攻击方法仍然是暴力攻击。虽然有 3 种理论攻击（差分密码分析、线性密码分析和改进的戴维斯攻击）的理论复杂性小于暴力破解，但需要不现实的已知明文或选择明文数量，并无实用价值。 DES 已被证明是一种设计良好的分组密码。除了暴力穷举密钥搜索外，DES 没有受到任何重要的密码分析攻击。为抵抗暴力破解，有大量的 DES 的代替算法，最重要的有 AES 和 3DES。","link":"/2020/06/12/%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86-DES/"},{"title":"Set Up a ZeroTier Network on OpenWRT","text":"PresentationIn this test, we set up Zerotier on GL.iNet’s mini-routers and an Ubuntu VPS so that they can access each other. To use ZeroTier service, you need to create your own ZeroTier account. Sign up for an account here: https://my.zerotier.com/login. Important: Stop other VPN service on the router before you start is recommended Login your ZeroTier account. Go to Network menu and click on Create buttonto create a new network. Next you should see the configuration page of your network. Please jot down the Network ID which will be used later. Setup ZeroTier on routerInstallationSSH to the router, and execute the following commands to install ZeroTier package: 12opkg updateopkg install zerotier ConfigurationZeroTierYou should edit the configuration file /etc/config/zerotier to enable ZeroTierand join into a network. It looks like: 1234# cat /etc/config/zerotierconfig zerotier 'sample_config' option enabled '1' list join 'd5e5fb6537869a7d' Please replace the code above d5e5fb6537869a7d with your own Network ID. Firewall(optional)If you want to access the router’s LAN, you have to configure the firewall aswell. Please edit the firewall configuration file /etc/config/firewall. Addbelow lines into it. 12345678910111213141516config zone 'vpn_zone' option name 'zerotier' option input 'ACCEPT' option forward 'REJECT' option output 'ACCEPT' option device 'zt+' option masq '1' option mtu_fix '1'config forwarding option dest 'zerotier' option src 'lan'config forwarding option dest 'lan' option src 'zerotier' Start ZeroTier Service12/etc/init.d/zerotier restart/etc/init.d/firewall restart Go back to your Zerotier’s web console and you will see the device which you just joined. Check the checkbox of “Auth?”, otherwise, your device may not be able to get an IP address from ZeroTier. After authentication, the network interface will obtain an IP address. Check itout via ifconfig, it looks like: 1234567891011# ifconfig ztwdjh372k Link encap:Ethernet HWaddr 7E:BD:F0:B6:4E:87 inet addr:10.241.143.3 Bcast:10.241.255.255 Mask:255.255.0.0 inet6 addr: fdd5:e5fb:6537:869a:7d99:9327:7681:2b7c/88 Scope:Global inet6 addr: fce2:6361:1827:7681:2b7c::1/40 Scope:Global inet6 addr: fe80::7cbd:f0ff:feb6:4e87/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:2800 Metric:1 RX packets:39 errors:0 dropped:0 overruns:0 frame:0 TX packets:68 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:1638 (1.5 KiB) TX bytes:4368 (4.2 KiB) Managed Routes(optional)You can manage route in ZeroTier’s web console. For example, I add a static route on Managed Routes, so that I can access the router’s LAN. Setup ZeroTier on UbuntuInstallationInstall ZeroTier and join the network which you created before. 12curl -s https://install.zerotier.com/ | sudo bashsudo zerotier-cli join d5e5fb6537869a7d Please replace the code above d5e5fb6537869a7d with your own Network ID. You need to check the checkbox of “Auth?” in ZeroTier’s web console as well. After authentication, the network interface will obtain an IP address. Check itout via ifconfig, it looks like: 1234567891011# ifconfig ztwdjh372k: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 2800 inet 10.241.116.0 netmask 255.255.0.0 broadcast 10.241.255.255 inet6 fe80::7cce:ffff:fee0:638c prefixlen 64 scopeid 0x20&lt;link&gt; inet6 fdd5:e5fb:6537:869a:7d99:9354:79d7:677 prefixlen 88 scopeid 0x0&lt;global&gt; inet6 fce2:6361:1854:79d7:677::1 prefixlen 40 scopeid 0x0&lt;global&gt; ether 7e:ce:ff:e0:63:8c txqueuelen 1000 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 85 bytes 4266 (4.2 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 TestingThe router and the Ubuntu VPS are able to ping each other. 1234567kyson@ip-172-31-34-95:~$ ping 10.241.143.3PING 10.241.143.3 (10.241.143.3) 56(84) bytes of data.64 bytes from 10.241.143.3: icmp_seq=1 ttl=64 time=1143 ms64 bytes from 10.241.143.3: icmp_seq=2 ttl=64 time=132 ms64 bytes from 10.241.143.3: icmp_seq=3 ttl=64 time=65.6 ms64 bytes from 10.241.143.3: icmp_seq=4 ttl=64 time=65.7 ms64 bytes from 10.241.143.3: icmp_seq=5 ttl=64 time=65.8 ms 123456root@GL-AR300M:/# ping 10.241.116.0PING 10.241.116.0 (10.241.116.0): 56 data bytes64 bytes from 10.241.116.0: seq=0 ttl=64 time=66.097 ms64 bytes from 10.241.116.0: seq=1 ttl=64 time=66.264 ms64 bytes from 10.241.116.0: seq=3 ttl=64 time=65.377 ms64 bytes from 10.241.116.0: seq=4 ttl=64 time=65.222 ms The Ubuntu VPS can reach router’s LAN if you configure the route. 1234567kyson@ip-172-31-34-95:~$ ping 192.168.8.1PING 192.168.8.1 (192.168.8.1) 56(84) bytes of data.64 bytes from 192.168.8.1: icmp_seq=1 ttl=64 time=65.7 ms64 bytes from 192.168.8.1: icmp_seq=2 ttl=64 time=66.0 ms64 bytes from 192.168.8.1: icmp_seq=3 ttl=64 time=65.6 ms64 bytes from 192.168.8.1: icmp_seq=4 ttl=64 time=65.8 ms64 bytes from 192.168.8.1: icmp_seq=6 ttl=64 time=65.2 ms TroubleshootingIf everthing is fine, but you can’t reach the router from Ubuntu VPS. It usually caused by mwan3, you can try to stop and remove it. 12mwan3 stopopkg remove mwan3 --force-depends","link":"/2020/06/12/Set-Up-a-ZeroTier-Network-on-OpenWRT/"},{"title":"Set Up a Tor Network on OpenWRT","text":"InstallationLogin to router’s console, and run the command to install Tor’s ipk. 12opkg updateopkg install tor tor-geoip ConfigurationConfiguring torCopying lines below and paste it into router’s command line, then press “Enter” key. It will override the torrc configuration file /etc/tor/torrc. 123456789101112131415161718cat &lt;&lt;EOT &gt; /etc/tor/torrcRunAsDaemon 1AllowUnverifiedNodes middle,rendezvousLog notice syslog## Only run as a client, never a relay or exitClientOnlyPidFile /var/run/tor.pidDataDirectory /var/lib/torUser torSocksPort 9050SocksPort 192.168.1.1:9050AutomapHostsSuffixes .onion,.exitAutomapHostsOnResolve 1VirtualAddrNetworkIPv4 10.192.0.0/10TransPort 192.168.1.1:9040DNSPort 192.168.1.1:9053ControlPort 9051EOT Configuring firewallAdd lines below into /etc/config/firewall. 123456789101112131415161718192021222324252627282930313233343536373839config zone 'tor' option name 'tor' option network 'lan' option input 'REJECT' option output 'ACCEPT' option forward 'REJECT' option conntrack '1' config rule option name 'Allow-Tor-DHCP' option src 'tor' option proto 'udp' option dest_port '67' option target 'ACCEPT' option family 'ipv4'config rule option name 'Allow-Tor-DNS' option src 'tor' option proto 'udp' option dest_port '9053' option target 'ACCEPT' option family 'ipv4'config rule option name 'Allow-Tor-Transparent' option src 'tor' option proto 'tcp' option dest_port '9040' option target 'ACCEPT' option family 'ipv4'config rule option name 'Allow-Tor-SOCKS' option src 'tor' option proto 'tcp' option dest_port '9050' option target 'ACCEPT' option family 'ipv4' Add lines below to /etc/firewall.user. 12345678910111213enable_transparent_tor() { ifname=br-lan # Allow direct access to the Tor daemon iptables -t nat -A PREROUTING -i $ifname -p tcp --dport 9050 -j ACCEPT # provide transparent routing for TCP and DNS iptables -t nat -A PREROUTING -i $ifname -p udp --dport 53 -j REDIRECT --to-ports 9053 iptables -t nat -A PREROUTING -i $ifname -p tcp --syn -j REDIRECT --to-ports 9040}enable_transparent_tor Start TorWe have to edit Tor’s init script /etc/init.d/tor, add those lines before procd_open_instance. 12lan_ip=$(uci get network.lan.ipaddr)[ -n &quot;$lan_ip&quot; ] &amp;&amp; sed -i &quot;s/192.168\\..*\\..*:/$lan_ip:/g&quot; /etc/tor/torrc All things done. Let’s start tor. 1/etc/init.d/tor restart Verify torVisti check.torproject.org to see if you are in tor network. Please note, when you are using tor, the router’s UI is not accessible as well. But you can ssh to the router.","link":"/2020/06/12/Set-Up-a-Tor-Network-on-OpenWRT/"},{"title":"Linux awk 命令入门教程","text":"printf 格式化输出awk 的格式化输出，和 C 语言的 printf 没什么区别。让我们来看一下以下的格式化输出示例： 12345678910输入：echo 123.4567 | awk '{printf &quot;%.3f\\n&quot;, $1}'输出：123.457# 不满8字符向左填充空格，并且只保留一位小数输入：echo 123.4567 | awk '{printf &quot;%8.1f\\n&quot;, $1}'输出： 123.5# 第一个元素不满20字符向右填充空格，并且保留七位小数；第二个元素以整形输出输入：echo 123.4567 55.2 | awk '{printf &quot;%-20.7f %d\\n&quot; , $1 , $2}'输出：123.4567000 55 格式控制的字符列表说明如下： 123456789101112131415161718192021222324252627`c' This prints a number as an ASCII character. Thus, `printf &quot;%c&quot;, 65' outputs the letter `A'. The output for a string value is the first character of the string. `d' This prints a decimal integer. `i' This also prints a decimal integer. `e' This prints a number in scientific (exponential) notation. For example, printf &quot;%4.3e&quot;, 1950 prints `1.950e+03', with a total of four significant figures of which three follow the decimal point. The `4.3' are modifiers, discussed below. `f' This prints a number in floating point notation. `g' This prints a number in either scientific notation or floating point notation, whichever uses fewer characters. `o' This prints an unsigned octal integer. `s' This prints a string. `x' This prints an unsigned hexadecimal integer. `X' This prints an unsigned hexadecimal integer. However, for the values 10 through 15, it uses the letters `A' through `F' instead of `a' through `f'. `%' This isn't really a format-control letter, but it does have a meaning when used after a `%': the sequence `%%' outputs one `%'. It does not consume an argument. BEGIN/END在读取第一个输入记录之前，BEGIN 规则仅执行一次。同样，在读取所有输入之后，END 规则仅执行一次。例如： 12345678910# awk -F&quot;:&quot; 'BEGIN{print &quot;Show all users:&quot;} {print $1} END{print &quot;====&gt; Successful!&quot;}' /etc/passwdShow all users:rootdaemonftpnetworknobodydnsmasqstubby====&gt; Successful! 内置变量FS 变量FS 变量用于指定输入字段的分隔符。 awk 默认以空白字符（空格或 tab）来解析从输入读取的每一行，并设置变量 $1，$2 等，FS 变量用于设置字段分隔符，它可以设置为任何单个字符或正则表达式。我们可以通过以下两种方式来使用 FS 变量： 命令行使用 -F 选项； 直接设置 FS 变量； 1234567Syntax:awk -F'FS' 'commands' inputfilename(or)awk 'BEGIN{FS=&quot;FS&quot;;}' 这是一个 awk FS 示例，以 “:” 作为分隔符处理 /etc/passwd 文件。为了易读，这里使用了 awk 脚本的形式。 1234567891011121314$ cat passwd.awk# 处理前BEGIN{ FS=&quot;:&quot;; print &quot;Name\\tUserID\\tGroupID\\tHomeDirectory&quot;;}# 处理中{ print $1&quot;\\t&quot;$3&quot;\\t&quot;$4&quot;\\t&quot;$6;}# 处理后END { print NR,&quot;Records Processed&quot;;} 12345678910# awk -f passwd.awk /etc/passwdName UserID GroupID Homeroot 0 0 /rootdaemon 1 1 /varftp 55 55 /home/ftpnetwork 101 101 /varnobody 65534 65534 /vardnsmasq 453 453 /var/run/dnsmasqstubby 410 410 /var/run/stubby7 Records Processed OFS 变量OFS 变量用于指定输出字段的分隔符。 OFS 是 FS 变量的输出等价物，默认值是空格。下面是使用 OFS 缺省值的示例： 12345678# awk -F':' '{print $3,$4;}' /etc/passwd0 01 155 55101 10165534 65534453 453410 410 print 语句中的 “,” 表示两个参数使用空格连接起来，也就是 OFS 的默认值。OFS 的值将被插入到输出字段间，示例如下： 12345678# awk -F':' 'BEGIN{OFS=&quot;=&quot;;} {print $3,$4;}' /etc/passwd0=01=155=55101=10165534=65534453=453410=410 RS 变量RS 变量用于指定输入字段的记录分隔符。 RS 定义了行，awk 缺省情况是以换行符为分隔符一行一行读取的，设置 RS 变量可以让 awk 按照 RS 的分隔符读取。 让我们把软件包信息存到一个文件，每个软件信息以一个空行作为分割，每个字段以换行符分隔。 12345678910111213141516171819202122# cat opkg.info Package: iwinfoVersion: 2018-07-24-94b1366d-2Depends: libc, libiwinfoStatus: install user installedArchitecture: mips_24kcInstalled-Time: 1553831708 Package: luci-mod-rpcVersion: git-18.196.56128-9112198-1Depends: libc, luci-lib-jsonStatus: install user installedArchitecture: allInstalled-Time: 1553831708Package: ubus Version: 2018-01-16-5bae22eb-1Depends: libc, libubus, libblobmsg-json, ubusdStatus: install ok installedArchitecture: mips_24kcInstalled-Time: 1553831711Auto-Installed: yes 以下是使用 RS 变量打印软件包名称的示例： 12345678910111213# cat opkg.awk BEGIN { RS=&quot;&quot;; FS=&quot; &quot;;}{ print $2;}# awk -f opkg.awk opkg.info iwinfoluci-mod-rpcubus 在 opkg.awk 脚本中，RS 被赋值为空，它将匹配到空行，因此把每个软件包详细信息作为单个记录读取，并且记录中的每一行都是一个字段，而分隔字段使用 FS 变量，为了提取软件包名称，这里使用了空格（” “)作为 FS 的分隔符。 ORS 变量ORS 变量用于指定输出字段的记录分隔符。 ORS 是 RS 变量的输出等价物，表示输出中的每条记录都将用这个分隔符打印。下面是使用 ORS 的示例： 12345678910111213141516171819# awk 'BEGIN{ORS=&quot;=&gt;&quot;; RS=&quot;&quot;} {print;}' opkg.info Package: iwinfoVersion: 2018-07-24-94b1366d-2Depends: libc, libiwinfoStatus: install user installedArchitecture: mips_24kcInstalled-Time: 1553831708 =&gt;Package: luci-mod-rpcVersion: git-18.196.56128-9112198-1Depends: libc, luci-lib-jsonStatus: install user installedArchitecture: allInstalled-Time: 1553831708=&gt;Package: ubus Version: 2018-01-16-5bae22eb-1Depends: libc, libubus, libblobmsg-json, ubusdStatus: install ok installedArchitecture: mips_24kcInstalled-Time: 1553831711Auto-Installed: yes=&gt; 上面的 awk 表达式中，以每个软件包信息作为一条记录，并且记录的输出用”=&gt;”分隔。 NR 变量NR 变量表示当前的记录数。 注意，不一定等于行数，如果设置了 RS 或 ORS，不再是按行读取，而是按 RS 或 ORS 分隔符读取，可以是单行，也可以是多行。 NR 表示已经读出的记录数或者行号，从 1 开始，如果有多个文件话，这个值也是不断累加中。 在下面的 NR 示例中，NR 变量记录当前的记录数，等同于行号，在 END 部分中，NR 告诉我们文件中的记录总数。 123456789101112131415161718192021222324252627# awk '{print &quot;Processing Record - &quot;,NR;}END {print NR, &quot;Packages Records are processed&quot;;}' opkg.info Processing Record - 1Processing Record - 2Processing Record - 3Processing Record - 4Processing Record - 5Processing Record - 6Processing Record - 7Processing Record - 8Processing Record - 9Processing Record - 10Processing Record - 11Processing Record - 12Processing Record - 13Processing Record - 14Processing Record - 15Processing Record - 16Processing Record - 17Processing Record - 18Processing Record - 19Processing Record - 20Processing Record - 21Processing Record - 22Processing Record - 23Processing Record - 24Processing Record - 2525 Packages Records are processed NF 变量NF 变量表示当前记录的字段总数，也就是列数。NF 对于验证记录中是否存在所有字段非常有用。 让我们来看一个学生成绩文件，其中有学生缺少一项成绩，如下所示。 123456cat student.txt Jones 78 84 77Gondrol 56 58 45RinRao 38 37Edwin 78 67 45Dayan 30 47 以下的 awk 脚本，打印记录(行)号和该记录中的字段数，很容易发现哪些学生的成绩缺少了。 123456# awk '{print NR,&quot;-&gt;&quot;,NF}' student.txt 1 -&gt; 42 -&gt; 43 -&gt; 34 -&gt; 45 -&gt; 3 FILENAME 变量FILENAME 变量表示当前输入的文件名。 以下的示例，在处理完后把当前的输入文件名打印出来： 12# awk 'END{print &quot;Current input file:&quot;, FILENAME}' student.txt Current input file: student.txt FNR 变量FNR 变量表示相对于当前输入文件的记录数。 与 NR 不同的是，这个值会是各个文件自己的行号，而 NR 对于多个文件，NR 的值是不断累加的。 我们处理单个文件的情况较多，多文件处理相对用的少。 Expressions as Patterns任何 awk 表达式都是合法的 awk 模式，如果表达式的值非零（对于整数）或者非空（对于字符串），则模式匹配。处理每条记录时，都会执行一次表达式。 Comparison expressionawk 支持比较表达式，比较运算符：==, !=, &gt;, &lt;, &gt;=, &lt;=。 以下示例通过比较表达式提取本机所有监听端口： 123456# netstat -nap | awk '$6 == &quot;LISTEN&quot; {print;}'tcp 0 0 0.0.0.0:139 0.0.0.0:* LISTEN 1833/smbdtcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 1652/lighttpdtcp 0 0 0.0.0.0:83 0.0.0.0:* LISTEN 1652/lighttpdtcp 0 0 127.0.0.1:53 0.0.0.0:* LISTEN 2858/dnsmasqtcp 0 0 192.168.17.211:53 0.0.0.0:* LISTEN 2858/dnsmasq Pattern matchawk 跟 grep 一样，支持模式匹配。模式匹配格式： 12345678910111213141516171819202122var ~ /regex/ &lt;=&gt; /regex/var !~ /regex/ &lt;=&gt; !/regex/``` 把上面的条件表达式改成模式匹配，其等价于： ``` # netstat -nap | awk '$6 ~ /LISTEN/ {print;}'tcp 0 0 0.0.0.0:139 0.0.0.0:* LISTEN 1833/smbdtcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 1652/lighttpdtcp 0 0 0.0.0.0:83 0.0.0.0:* LISTEN 1652/lighttpdtcp 0 0 127.0.0.1:53 0.0.0.0:* LISTEN 2858/dnsmasqtcp 0 0 192.168.17.211:53 0.0.0.0:* LISTEN 2858/dnsmasq(or)# netstat -nap | awk '/LISTEN/ {print;}'tcp 0 0 0.0.0.0:139 0.0.0.0:* LISTEN 1833/smbdtcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 1652/lighttpdtcp 0 0 0.0.0.0:83 0.0.0.0:* LISTEN 1652/lighttpdtcp 0 0 127.0.0.1:53 0.0.0.0:* LISTEN 2858/dnsmasqtcp 0 0 192.168.17.211:53 0.0.0.0:* LISTEN 2858/dnsmasq Exampleopkg.info 文件记录了软件包信息，其中自动安装的软件包会包含 “Auto-Installed: yes” 字段。 12345678910111213141516171819202122# cat opkg.info Package: iwinfoVersion: 2018-07-24-94b1366d-2Depends: libc, libiwinfoStatus: install user installedArchitecture: mips_24kcInstalled-Time: 1553831708Package: luci-mod-rpcVersion: git-18.196.56128-9112198-1Depends: libc, luci-lib-jsonStatus: install user installedArchitecture: allInstalled-Time: 1553831708Package: ubus Version: 2018-01-16-5bae22eb-1Depends: libc, libubus, libblobmsg-json, ubusdStatus: install ok installedArchitecture: mips_24kcInstalled-Time: 1553831711Auto-Installed: yes 下面的示例使用了模式匹配的取反规则来打印所有非自动安装的软件包名称： 12# awk 'BEGIN{ORS=&quot; &quot;;RS=&quot;&quot;};!/Auto-Installed/{print $2}' opkg.info iwinfo luci-mod-rpc See alsohttps://www.gnu.org/software/gawk/manual/html_node/Expression-Patterns.html","link":"/2020/06/12/Linux-awk-%E5%91%BD%E4%BB%A4%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"},{"title":"Linux Shell 变量参数扩展教程","text":"shell参数扩展说明shell 参数扩展格式： 1${expression} expression 表达式可以为任意的字符，直到匹配到 ‘}’ 为止，因此表达式包含 ‘}’ 的话需要用转义或者用单引号包含起来。 值替换1234567891011${parameter:-word}如果 parameter 为 null 或者未设置，整个参数替换表达式值为 word ${parameter:=word}如果 parameter 为 null 或者未设置，整个参数替换表达式值为 word，并且 parameter 参数值设置为 word ${parameter:?word}如果 parameter 为 null 或者未设置，则打印出错误信息。否则，整个参数替换表达式值为 $parameter ${parameter:+word}如果 parameter 不为 null 或者未设置，则整个参数替换表达式值为 word 字符串替换12345${parameter/pattern/string}${parameter//pattern/string}将 parameter 对应值的 pattern 字符串替换成为 string 字符串/表示只替换一次//表示全部替换 例子： 12345678910${parameter/pattern/string}var=&quot;3/1/2/3333&quot;echo ${var/3/6}6/1/2/3333${parameter//pattern/string}var=&quot;3/1/2/3333&quot;echo ${var//3/6}6/1/2/6666 字符串长度12${#parameter}获得字符串的长度 例子： 12345${#parameter}var=&quot;Hello&quot;echo ${#var}5 字符过滤1234567891011${parameter%word}${parameter%%word}word 支持通配符，从尾开始匹配 word，将匹配 word 正则表达式的字符删除% 为最短匹配，%% 为最长匹配 ${parameter#word}${parameter##word}word 支持通配符，从头开始扫描 word，将匹配 word 正则表达的字符删除#为最短匹配，##为最长匹配注意，匹配成功就停止继续匹配，也就是只匹配一次。最长匹配一般是针对通配符，能够匹配到最长字符串，也就是即时匹配成功，还会继续匹配，取最后一次匹配成功的。 例子： 1234567891011121314151617181920212223${parameter%word}x=file.cecho ${x%.c}.ofile.o${parameter%%word}x=posix/src/stdecho ${x%%/*}posix${parameter#word}x=$HOME/src/cmdecho ${x#$HOME}/src/cmd${parameter##word}x=/one/two/threeecho ${x##*/}three See alsohttp://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_06_02","link":"/2020/06/12/Linux-Shell-%E5%8F%98%E9%87%8F%E5%8F%82%E6%95%B0%E6%89%A9%E5%B1%95%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Gitee","slug":"Gitee","link":"/tags/Gitee/"},{"name":"图床","slug":"图床","link":"/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"密码学","slug":"密码学","link":"/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"Latex","slug":"Latex","link":"/tags/Latex/"},{"name":"VSCode","slug":"VSCode","link":"/tags/VSCode/"},{"name":"OpenWRT","slug":"OpenWRT","link":"/tags/OpenWRT/"},{"name":"VPN","slug":"VPN","link":"/tags/VPN/"},{"name":"Router","slug":"Router","link":"/tags/Router/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"awk","slug":"awk","link":"/tags/awk/"},{"name":"shell","slug":"shell","link":"/tags/shell/"}],"categories":[{"name":"垃圾桶","slug":"垃圾桶","link":"/categories/%E5%9E%83%E5%9C%BE%E6%A1%B6/"},{"name":"密码学与安全","slug":"密码学与安全","link":"/categories/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%8E%E5%AE%89%E5%85%A8/"},{"name":"办公利器","slug":"办公利器","link":"/categories/%E5%8A%9E%E5%85%AC%E5%88%A9%E5%99%A8/"},{"name":"VPN","slug":"VPN","link":"/categories/VPN/"},{"name":"脚本语言","slug":"脚本语言","link":"/categories/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80/"}]}