<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Gitee搭建个人图床</title>
    <url>/2020/06/07/Gitee%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>利用 PicGo 工具把本地图片上传到 Gitee，来实现个人图床。选择 Gitee 的原因是因为在国内访问 Gitee 较快，访问 GitHub 是蜗牛的速度。PicGo 默认不支持 Gitee 作为图床，要安装 <code>gitee-uploader</code> 插件。  </p>
<a id="more"></a>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li>下载并安装 <a href="https://github.com/Molunerfinn/PicGo/releases">PicGo</a>；  </li>
<li>下载并安装 <a href="https://nodejs.org/en/download/">node.js</a>；  </li>
<li>打开 PicGo，在【插件设置】搜索并安装 <code>gitee-uploader</code>插件。  </li>
</ul>
<h2 id="配置图床"><a href="#配置图床" class="headerlink" title="配置图床"></a>配置图床</h2><p>在 PicGo 的【图床设置】- 【gitee】设置图床的配置，配置之前要在 Gitee 上新建一个用于存放图床的仓库，配置如下：   </p>
<p><img src="https://gitee.com/kysonlok/imgurl/raw/master/img/20200607020745.jpg" alt=""></p>
<ul>
<li><p>repo：Gitee 上的仓库链接  </p>
</li>
<li><p>branch：仓库的分支  </p>
</li>
<li><p>token：Gitee 的私人令牌，点击头像 -【设置】-【私人令牌】，再点击<code>生成新令牌</code>，验证密码之后会生成一个 token，把 token 复制到配置中  </p>
<blockquote>
<p>注意，令牌只会明文显示一次，建议在配置插件的时候再来生成令牌，直接复制进去，忘记了要重新生成。  </p>
</blockquote>
</li>
<li><p>path：可选项，指定图片上传到 Gitee 仓库的哪个目录  </p>
</li>
<li><p>customPath 和 customUrl：提交的 message，保持默认就好  </p>
</li>
</ul>
<p>点击<code>设为默认图床</code>完成配置，回到<code>上传区</code>就可以使用了。  </p>
<h2 id="配置-PicGo"><a href="#配置-PicGo" class="headerlink" title="配置 PicGo"></a>配置 PicGo</h2><p>PicGo 默认不对上传图片进行修改，我一般不关心图片的命名，因此设置 PicGo 在上传之前使用时间戳重命名图片。  </p>
<p>点击 <code>PicGo设置</code> ，开启 <code>上传前重命名</code> 和 <code>时间戳重命名</code>。  </p>
]]></content>
      <categories>
        <category>垃圾桶</category>
      </categories>
      <tags>
        <tag>Gitee</tag>
        <tag>图床</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo Icarus 支持Latex数学公式</title>
    <url>/2020/06/11/Hexo-Icarus-%E6%94%AF%E6%8C%81Latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="支持-MathJax"><a href="#支持-MathJax" class="headerlink" title="支持 MathJax"></a>支持 MathJax</h2><p>Icarus 主题默认支持了 MathJax 插件渲染数学公式，只需要在主题配置文件 <code>theme/icarus/_config.yml</code> 使能就可以直接使用。  </p>
<p>关于更多说明，可以参考 <a href="https://blog.zhangruipeng.me/hexo-theme-icarus/Plugins/Other/icarus-user-guide-other-plugins/#MathJax">icarus-user-guide-other-plugins-MathJax</a>。  </p>
<a id="more"></a>  

<p>要注意的地方是，如果使用了多个配置文件，如默认配置使用 <code>theme/icarus/_config.yml</code>，文章页面配置使用 <code>theme/icarus/_config.yml</code>，则需要在文章页面配置 <code>theme/icarus/_config.yml</code> 里面使能 MathJax。  </p>
<h2 id="语法渲染错误"><a href="#语法渲染错误" class="headerlink" title="语法渲染错误"></a>语法渲染错误</h2><p>由于 Latex 和 Markdown 有些语法会冲突，如下划线 <code>_</code>，在 Markdown 被渲染成斜体。有两种解决办法：  </p>
<p>使用转义字符 <code>\</code>：    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\hat&#123;x&#125;_&#123;k&#125;&#x3D;\hat&#123;x&#125;_&#123;k&#125;^&#123;-&#125;+K_&#123;t&#125;\left(y_&#123;k&#125;\right)</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>

<p>使用 HTML 标签，内联表达式用 <code>&lt;span&gt;&lt;/span&gt;</code>，块表达式用 <code>&lt;div&gt;&lt;/div&gt;</code>：     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">$$</span><br><span class="line">\hat&#123;x&#125;_&#123;k&#125;&#x3D;\hat&#123;x&#125;_&#123;k&#125;^&#123;-&#125;+K_&#123;t&#125;\left(y_&#123;k&#125;\right)</span><br><span class="line">$$</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<h2 id="预览效果"><a href="#预览效果" class="headerlink" title="预览效果"></a>预览效果</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This is inline expression: $ax^2+bx+c&gt;0$.</span><br><span class="line"></span><br><span class="line">This is a block expression:</span><br><span class="line">$$\displaystyle \frac&#123;1&#125;&#123;\Bigl(\sqrt&#123;\phi \sqrt&#123;5&#125;&#125;-\phi\Bigr) e^&#123;\frac25 \pi&#125;&#125; &#x3D; </span><br><span class="line">1+\frac&#123;e^&#123;-2\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-4\pi&#125;&#125; &#123;1+\frac&#123;e^&#123;-6\pi&#125;&#125; </span><br><span class="line">&#123;1+\frac&#123;e^&#123;-8\pi&#125;&#125; &#123;1+\cdots&#125; &#125; &#125; &#125;$$</span><br><span class="line"></span><br><span class="line">Or use $LaTeX$ environment:  </span><br><span class="line">&lt;div&gt;</span><br><span class="line">\begin&#123;equation&#125;</span><br><span class="line">A &#x3D;</span><br><span class="line">\begin&#123;bmatrix&#125;</span><br><span class="line">  a &amp; b \\</span><br><span class="line">  c &amp; c</span><br><span class="line">\end&#123;bmatrix&#125;</span><br><span class="line">\end&#123;equation&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>This is another inline expression: $ax^2+bx+c&gt;0$.  </p>
<p>This is a block expression:  </p>
<p>$$\displaystyle \frac{1}{\Bigl(\sqrt{\phi \sqrt{5}}-\phi\Bigr) e^{\frac25 \pi}} =<br>1+\frac{e^{-2\pi}} {1+\frac{e^{-4\pi}} {1+\frac{e^{-6\pi}}<br>{1+\frac{e^{-8\pi}} {1+\cdots} } } }$$  </p>
<p>use $LaTeX$ environment:</p>
<div>
\begin{equation}
A =
\begin{bmatrix}
  a & b \\
  c & c
\end{bmatrix}
\end{equation}
</div>]]></content>
      <categories>
        <category>垃圾桶</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo NextT 主题设置</title>
    <url>/2020/06/03/Hexo-NextT-%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="安装和开始"><a href="#安装和开始" class="headerlink" title="安装和开始"></a>安装和开始</h2><p>按照 <a href="https://hexo.io/docs/">Hexo 官方文档</a>的指导安装 Hexo，并且使用 <code>hexo init</code> 创建一个博客站点。  </p>
<p>切换到博客根目录，下载 NextT 主题：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h2><p>hexo 版本: 4.2.0<br>next 版本: 7.8.0  </p>
<blockquote>
<p>注意时效性，版本不同配置项可能存在差异。  </p>
</blockquote>
<h2 id="NextT-主题配置"><a href="#NextT-主题配置" class="headerlink" title="NextT 主题配置"></a>NextT 主题配置</h2><h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3><p>使用 NextT 主题，并且设置语言为中文，修改博客根目录下的 <code>_config.yml</code> 文件：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">language: zh-CN  </span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<p>接着修改主题风格，在 theme 配置 <code>themes/next/_config.yml</code> 文件找到 scheme 字段，选择主题风格。目前支持四种：Muse, Mist, Pisces 和 Gemini，任意选择一种合适的，我这里用的是 <code>Mist</code> 方案。    </p>
<h3 id="设置菜单"><a href="#设置菜单" class="headerlink" title="设置菜单"></a>设置菜单</h3><p>在 theme 配置 <code>themes/next/_config.yml</code> 文件找到 menu 字段，可以根据个人偏好设置菜单。我这里保留了分类 categories，标签 tags，归档 archives 和 关于 about，|| 后面表示图标，这里不作修改。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F; || fa fa-home</span><br><span class="line">  categories: &#x2F;categories&#x2F; || fa fa-th</span><br><span class="line">  tags: &#x2F;tags&#x2F; || fa fa-tags</span><br><span class="line">  archives: &#x2F;archives&#x2F; || fa fa-archive</span><br><span class="line">  about: &#x2F;about&#x2F; || fa fa-user</span><br><span class="line">  #schedule: &#x2F;schedule&#x2F; || fa fa-calendar</span><br><span class="line">  #sitemap: &#x2F;sitemap.xml || fa fa-sitemap</span><br><span class="line">  #commonweal: &#x2F;404&#x2F; || fa fa-heartbeat</span><br></pre></td></tr></table></figure>

<h3 id="创建页面"><a href="#创建页面" class="headerlink" title="创建页面"></a>创建页面</h3><p>设置完菜单，由于新增的菜单栏没有对应的页面，点击会提示找不到页面，执行以下命令为新增的菜单栏添加对应的页面：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br><span class="line">hexo new page categories</span><br><span class="line">hexo new page about</span><br></pre></td></tr></table></figure>

<p>成功执行以上命令，在 <code>sources</code> 目录下会生成对应的文件夹，每个文件夹里包含一个 <code>index.md</code> 文件。</p>
<h3 id="文章显示"><a href="#文章显示" class="headerlink" title="文章显示"></a>文章显示</h3><p>默认首页的文章会显示全文，可以在原文插入 <code>&lt;!-- more --&gt;</code> 标签，会自动把该标签前面的文本生成摘要显示。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line">Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</span><br></pre></td></tr></table></figure>

<h3 id="显示头像和-favicon"><a href="#显示头像和-favicon" class="headerlink" title="显示头像和 favicon"></a>显示头像和 favicon</h3><p>在 theme 配置 <code>themes/next/_config.yml</code> 文件找到 avatar 字段，设置 url 为头像文件(头像放置的路径为 <code>themes/next/source/images</code>) 。我比较喜欢头像呈圆形，这里把 <code>rounded</code> 的值改为了 true。    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">avatar:</span><br><span class="line">  # Replace the default image and set the url here.</span><br><span class="line">  # url: #&#x2F;images&#x2F;avatar.gif</span><br><span class="line">  url: &#x2F;images&#x2F;avatar.png</span><br><span class="line">  # If true, the avatar will be dispalyed in circle.</span><br><span class="line">  rounded: true</span><br><span class="line">  # If true, the avatar will be rotated with the cursor.</span><br><span class="line">  rotated: false</span><br></pre></td></tr></table></figure>

<p>可以使用 <a href="https://favicon.io/favicon-generator/">favicon-generator</a> 网站制作 favicon，制作完之后下载，把制作好的 favicon 放置到 <code>themes/next/source/images</code> 目录下，在 theme 配置 <code>themes/next/_config.yml</code> 文件找到 favicon 字段，把相应的文件名改成上传的新 favicon 文件名。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: &#x2F;images&#x2F;favicon-16x16.png</span><br><span class="line">  medium: &#x2F;images&#x2F;favicon-32x32.png</span><br><span class="line">  apple_touch_icon: &#x2F;images&#x2F;apple-touch-icon.png</span><br><span class="line">  safari_pinned_tab: &#x2F;images&#x2F;logo.svg</span><br><span class="line">  #android_manifest: &#x2F;images&#x2F;manifest.json</span><br><span class="line">  #ms_browserconfig: &#x2F;images&#x2F;browserconfig.xml</span><br></pre></td></tr></table></figure>

<h3 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h3><p>在 theme 配置 <code>themes/next/_config.yml</code> 文件找到 local_search 字段，把值改为 true。并且在博客根目录下的<code>_config.yml</code> 文件添加以下内容：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，搜索功能依赖 <a href="https://github.com/theme-next/hexo-generator-searchdb，在博客根目录执行">https://github.com/theme-next/hexo-generator-searchdb，在博客根目录执行</a> <code>npm install hexo-generator-searchdb --save</code> 进行安装。  </p>
</blockquote>
<h3 id="加载进度条"><a href="#加载进度条" class="headerlink" title="加载进度条"></a>加载进度条</h3><p>在 theme 配置 <code>themes/next/_config.yml</code> 文件找到 pace 字段，把值改为 true，根据个人偏好选择任意一种提供的样式填入 pace_theme。  </p>
<blockquote>
<p>注意，进度条依赖 <a href="https://github.com/theme-next/theme-next-pace，按照">https://github.com/theme-next/theme-next-pace，按照</a> theme-next-pace 的 README 说明进行安装。  </p>
</blockquote>
<h3 id="Fork-me-on-GitHub"><a href="#Fork-me-on-GitHub" class="headerlink" title="Fork me on GitHub"></a>Fork me on GitHub</h3><p>在 <a href="http://tholman.com/github-corners/">github-corners</a> 或者 <a href="https://github.blog/2008-12-19-github-ribbons/">github-ribbons</a> 选择自己喜欢的样式，复制插入到 <code>themes/next/layout/_layout.swig</code> 文件中 <code>&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;</code> 位置后面。    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;headband&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;github.com&#x2F;kysonlok&quot;&gt;......</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>垃圾桶</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo Icarus 主题设置</title>
    <url>/2020/06/05/Hexo-Icarus-%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="安装和开始"><a href="#安装和开始" class="headerlink" title="安装和开始"></a>安装和开始</h2><p>按照 <a href="https://hexo.io/docs/">Hexo 官方文档</a>的指导安装 Hexo，并且使用 <code>hexo init</code> 创建一个博客站点。  </p>
<p>切换到博客根目录，下载 NextT 主题并安装依赖模块：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;ppoffice&#x2F;hexo-theme-icarus.git themes&#x2F;icarus</span><br><span class="line">npm install bulma-stylus@0.8.0 hexo-component-inferno hexo-renderer-inferno inferno  inferno-create-element --save</span><br></pre></td></tr></table></figure>

<a id="more"></a>  

<h2 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h2><p>Hexo 版本: 4.2.0<br>Icarus 版本: 3.1.0  </p>
<blockquote>
<p>注意时效性，版本不同配置项可能存在差异。  </p>
</blockquote>
<h2 id="Icarus-主题配置"><a href="#Icarus-主题配置" class="headerlink" title="Icarus 主题配置"></a>Icarus 主题配置</h2><h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3><p>使用 Icarus 主题，并且设置语言为中文，修改博客根目录下的 <code>_config.yml</code> 文件：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">language: zh-CN  </span><br><span class="line">theme: icarus</span><br></pre></td></tr></table></figure>

<p>Icarus 为我们预置了多达 12 种语言，默认是英文。zh-CN 是简体中文，大家可以根据自己的文案风格修改 <code>theme/icarus/languages/zh-CN.yml</code> 文件。    </p>
<h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><p>首次在博客根目录执行 <code>hexo clean</code> 或者 <code>hexo g</code> 都会触发 Icarus 自动生成一个 <code>theme/icarus/_config.yml</code> 文件。  </p>
<h3 id="logo-设置"><a href="#logo-设置" class="headerlink" title="logo 设置"></a>logo 设置</h3><p>logo 会展示在顶部导航栏的最左侧以及底部的 footer 区域，大家可以替换 <code>source/images/</code> 下的 logo 文件，使用 svg 或者 png 格式的都可以。    </p>
<h3 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h3><p>Icarus 预置了 Changyan, Disqus, Facebook, Gitment, Gitalk, Isso, LiveRe 和 Valine 八大主流评论插件。</p>
<p>这里以我使用的 Valine 为例。首先在 <a href="https://www.leancloud.cn/">LeanCloud</a> 注册一个免费的开发账号，新建一个新应用，并把 appid 和 appkey 配置在对应部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">comment:</span><br><span class="line">    type: valine</span><br><span class="line">    app_id: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">    app_key: xxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">    placeholder: &quot;&quot;                 # 可选填</span><br><span class="line">    avatar: mm                      # 可选填</span><br><span class="line">    avatar_force: false             # 可选填</span><br><span class="line">    meta: [&quot;nick&quot;, &quot;mail&quot;, &quot;link&quot;]  # 可选填</span><br><span class="line">    page_size: 10                   # 可选填</span><br><span class="line">    lang: zh-CN                     # 可选填</span><br><span class="line">    visitor: false                  # 可选填</span><br><span class="line">    highlight: true                 # 可选填</span><br><span class="line">    record_ip: false                # 可选填</span><br><span class="line">    server_urls:                    # 可选填</span><br><span class="line">    emoji_cdn:                      # 可选填</span><br><span class="line">    emoji_maps:                     # 可选填</span><br><span class="line">    enable_qq: false                # 可选填</span><br><span class="line">    required_fields: []             # 可选填</span><br></pre></td></tr></table></figure>

<p>其他的评论插件配置，具体可以参见<a href="https://blog.zhangruipeng.me/hexo-theme-icarus/Plugins/Comment/icarus用户指南-用户评论插件/">用户评论插件</a>。  </p>
<p>如果有的文章不希望别人评论，但是我们又不希望把整个站点的评论关闭的话，可以对指定文章进行评论关闭操作。操作也很简单，只需要在文章 markdown 文件的 front-matter 区域设置 <code>comments</code> 为 <code>false</code> 即可：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: article title</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h3 id="打赏功能"><a href="#打赏功能" class="headerlink" title="打赏功能"></a>打赏功能</h3><p>Icarus 提供了支付宝，微信，PayPal 和 Patreon 四种支付方式：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">donates:</span><br><span class="line">    # Alipay donate button configurations</span><br><span class="line">    -</span><br><span class="line">        type: alipay</span><br><span class="line">        # Alipay qrcode image URL</span><br><span class="line">        qrcode: &#x2F;img&#x2F;alipay.jpg</span><br><span class="line">    # &quot;Buy me a coffee&quot; donate button configurations</span><br><span class="line">    # -</span><br><span class="line">        # type: buymeacoffee</span><br><span class="line">        # URL to the &quot;Buy me a coffee&quot; page</span><br><span class="line">        # url: &#39;&#39;</span><br><span class="line">    # Patreon donate button configurations</span><br><span class="line">    # -</span><br><span class="line">        # type: patreon</span><br><span class="line">        # URL to the Patreon page</span><br><span class="line">        # url: &#39;&#39;</span><br><span class="line">    # Paypal donate button configurations</span><br><span class="line">    # -</span><br><span class="line">        # type: paypal</span><br><span class="line">        # Paypal business ID or email address</span><br><span class="line">        # business: &#39;&#39;</span><br><span class="line">        # Currency code</span><br><span class="line">        # currency_code: USD</span><br><span class="line">    # Wechat donate button configurations</span><br><span class="line">    -</span><br><span class="line">        type: wechat</span><br><span class="line">        # Wechat qrcode image URL</span><br><span class="line">        qrcode: &#x2F;img&#x2F;wechat.jpg</span><br></pre></td></tr></table></figure>

<p>支付宝和微信只需要提供二维码就可以了，可以使用本地静态资源或者图床链接。    </p>
<h3 id="widget-挂件"><a href="#widget-挂件" class="headerlink" title="widget 挂件"></a>widget 挂件</h3><p>挂件是 Icarus 比较精髓的部分，所有的 widget 都是一个卡片，可以自由摆放在任何位置。包括文章在内，个人资料、链接、分类、最新文章、归档、标签都是一个卡片，可以在 <code>theme/icarus/_config.yml</code> 中设置各个卡片的具体属性，同时也可以设置卡片出现在网站的左侧还是右侧。   </p>
<p>除了在 <code>themes/icarus/_config.yml</code> 的默认主题配置文件外，Icarus 也会从<code>themes/icarus/_config.post.yml</code> 和 <code>themes/icarus/_config.page.yml</code> 获取替代配置。可以在<code>_config.post.yml</code> 中设置仅对所有文章生效的配置， 例如，在此配置文件中把所有的挂件放置在页面一侧来实现所有文章两栏布局，同时其他页面仍保持三栏布局。详细使用可以参见 <a href="https://blog.zhangruipeng.me/hexo-theme-icarus/Configuration/icarus用户指南-主题配置/#配置文件与优先级">icarus用户指南-主题配置-配置文件与优先级</a>。    </p>
<blockquote>
<p>一般文章是 post layout，about/categories/tags 这些是 page layout。  </p>
</blockquote>
<p>为了页面简洁大方，主页删除了大部分不需要的挂件，左侧只保留个人资料，右侧保留标签、分类和归档。文章页面只保留目录。  </p>
<p><code>themes/icarus/_config.yml</code> 挂件配置：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">widgets:</span><br><span class="line">    # Profile widget configurations</span><br><span class="line">    -</span><br><span class="line">        # Where should the widget be placed, left sidebar or right sidebar</span><br><span class="line">        position: left</span><br><span class="line">        type: profile</span><br><span class="line">        # Author name</span><br><span class="line">        author: Kyson Lok</span><br><span class="line">        # Author title</span><br><span class="line">        author_title: Developer</span><br><span class="line">        # Author&#39;s current location</span><br><span class="line">        location: ShenZhen, China</span><br><span class="line">        # URL or path to the avatar image</span><br><span class="line">        avatar: &#x2F;img&#x2F;avatar.png</span><br><span class="line">        # Whether show the rounded avatar image</span><br><span class="line">        avatar_rounded: true</span><br><span class="line">        # Email address for the Gravatar</span><br><span class="line">        gravatar: </span><br><span class="line">        # URL or path for the follow button</span><br><span class="line">        follow_link: &#39;https:&#x2F;&#x2F;github.com&#x2F;kysonlok&#39;</span><br><span class="line">        # Links to be shown on the bottom of the profile widget</span><br><span class="line">        social_links:</span><br><span class="line">            Github:</span><br><span class="line">                icon: fab fa-github</span><br><span class="line">                url: &#39;https:&#x2F;&#x2F;github.com&#x2F;kysonlok&#39;</span><br><span class="line">            Facebook:</span><br><span class="line">                icon: fab fa-facebook</span><br><span class="line">                url: &#39;https:&#x2F;&#x2F;facebook.com&#39;</span><br><span class="line">            Twitter:</span><br><span class="line">                icon: fab fa-twitter</span><br><span class="line">                url: &#39;https:&#x2F;&#x2F;twitter.com&#39;</span><br><span class="line">            Dribbble:</span><br><span class="line">                icon: fab fa-dribbble</span><br><span class="line">                url: &#39;https:&#x2F;&#x2F;dribbble.com&#39;</span><br><span class="line">            # RSS:</span><br><span class="line">                # icon: fas fa-rss</span><br><span class="line">                # url: &#x2F;</span><br><span class="line">    -</span><br><span class="line">        # Where should the widget be placed, left sidebar or right sidebar</span><br><span class="line">        position: right</span><br><span class="line">        type: tags</span><br><span class="line">    # Categories widget configurations</span><br><span class="line">    -</span><br><span class="line">        # Where should the widget be placed, left sidebar or right sidebar</span><br><span class="line">        position: right</span><br><span class="line">        type: categories</span><br><span class="line">    # Archives widget configurations</span><br><span class="line">    -</span><br><span class="line">        # Where should the widget be placed, left sidebar or right sidebar</span><br><span class="line">        position: right</span><br><span class="line">        type: archives</span><br></pre></td></tr></table></figure>

<p><code>themes/icarus/_config.post.yml</code> 挂件配置：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">widgets:</span><br><span class="line">    -</span><br><span class="line">        # Where should the widget be placed, left sidebar or right sidebar</span><br><span class="line">        position: right</span><br><span class="line">        type: toc</span><br></pre></td></tr></table></figure>

<p><code>themes/icarus/_config.page.yml</code> 配置跟 <code>themes/icarus/_config.post.yml</code> 保持一致。</p>
]]></content>
      <categories>
        <category>垃圾桶</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>费斯妥密码</title>
    <url>/2020/06/10/%E8%B4%B9%E6%96%AF%E5%A6%A5%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h2 id="Feistel-概述"><a href="#Feistel-概述" class="headerlink" title="Feistel 概述"></a>Feistel 概述</h2><p>Feistel（费斯妥）密码结构，在密码学研究中，Feistel 密码结构是用于分组密码中的一种对称结构，它本身并不是分组密码算法的具体方案，而是一种设计模型。  </p>
<p>很多对称分组加密算法都是基于 Feistel 分组密码结构的，其中包括 DES。Feistel 结构是由许多相同的轮函数组成，每轮使用不同的子密钥，每轮包含了代替和置换两个步骤。  </p>
<a id="more"></a>  

<h2 id="构造细节"><a href="#构造细节" class="headerlink" title="构造细节"></a>构造细节</h2><p>令 F 为轮函数；令 $K_1, K_2, …, K_n$ 分别为第 1, 2, …, n 轮的子密钥。  </p>
<p><img src="https://gitee.com/kysonlok/imgurl/raw/master/img/20200610225949.png" alt=""></p>
<h3 id="加密明文过程"><a href="#加密明文过程" class="headerlink" title="加密明文过程"></a>加密明文过程</h3><ol>
<li><p>将明文块拆分为两个等长的块：($L_0, R_0$)；  </p>
</li>
<li><p>在每一轮中，右半部分 $R_i$ 保持不变，作为左半部分下一轮 $L_{i+1}$ 的输入；而左半部分 $L_i$ 经过一个依赖右半部分 $R_i$ 和 子密钥 $K_i$ 的运算，作为右半部分下一轮 $R_{i+1}$ 的输入。  </p>
</li>
<li><p>运算的规则为，我们使用一个加密函数 F，它接受两个输入——密钥 K 和 R，该函数的输出为 F(R, K)，然后将左半部分 $L_i$ 和加密函数结果进行异或计算，得到的结果为 $R_{i+1}$。    </p>
</li>
</ol>
<div>
   $$
   L_{i+1} = R_i\\
   R_{i+1} = L_i{\oplus}F(R_i, K_i)
   $$
</div>

<ol start="4">
<li>依次进行 n 轮计算，当最后一轮完成后，两个子块 $R_{n+1}$ 和 $L_{n+1}$ 按顺序连接起来，形成密文块($R_{n+1}, L_{n+1}$)。  </li>
</ol>
<h3 id="解密密文过程"><a href="#解密密文过程" class="headerlink" title="解密密文过程"></a>解密密文过程</h3><ol>
<li><p>对于密文($R_{n+1}, L_{n+1}$)，通过计算 i = n, n-1, ……, 0，对密文进行加密的逆向操作；  </p>
</li>
<li><p>在每一轮中，进行如下运算（i 为当前轮数）  </p>
</li>
</ol>
<div>
   $$
   R_i = L_{i+1}\\
   L_i = R_{i+1}{\oplus}F(L_{i+1}, K_i)
   $$
</div>

<ol start="3">
<li>依次进行 n 轮计算，结果($R_0, L_0$)就是明文。   </li>
</ol>
<h3 id="置换与代替"><a href="#置换与代替" class="headerlink" title="置换与代替"></a>置换与代替</h3><p><strong>置换</strong>步骤是指修改过的 L 和未修改过的 R 进行了交换。$L_i$ 经过运算变成了 $R_{i+1}$，$R_i$ 变成了 $L_{i+1}$。    </p>
<p><strong>代替</strong>步骤是指每个明文元素或元素组被唯一地替换为相应的密文元素或元素组。  </p>
<h2 id="影响因素"><a href="#影响因素" class="headerlink" title="影响因素"></a>影响因素</h2><p>影响Feistel 结构的因素有如下 5 个：  </p>
<ul>
<li>块的大小：大的块会提高加密的安全性，但是会降低加密、解密的速度。截止至2013年，比较流行的这种方案是 64 bit。而 128 bit 的使用也比较广泛。  </li>
<li>密钥的大小：同上。现在流行的是 64 bit ，而 128 bit 正逐渐成为主流。  </li>
<li>迭代轮数：Feistel 密码的轮数量取决于系统所需的安全性，轮数越多系统越安全。但更多的轮数意味着加密和解密过程增多，效率越低。现阶段比较流行的是 16 轮。  </li>
<li>子密钥的生成算法：生成算法越复杂，则会使得密码被破译的难度增强，即，信息会越安全。  </li>
<li>轮函数的复杂度：轮函数越复杂，则安全性越高。  </li>
</ul>
]]></content>
      <categories>
        <category>密码学与安全</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode配置</title>
    <url>/2020/06/11/VSCode%E5%BC%80%E5%8F%91%E5%88%A9%E5%99%A8/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>工欲善其事，必先利其器。好的开发工具，能大大地提高开发的效率。以前一直使用 VIM 写代码，用 Source Insight 看代码，后来在朋友的推荐下切换到 VSCode，使用了一段时间，发现 VSCode 真的超级强大好用，而且是开源的，不得不让人青睐。写篇文章记录一下 VSCode 的配置以及插件，以便后续重新搭建环境可以作为参考。  </p>
<a id="more"></a>  

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>进入官网 <a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a> 下载并安装。  </p>
<h2 id="集成-cmder"><a href="#集成-cmder" class="headerlink" title="集成 cmder"></a>集成 cmder</h2><p>cmder 也是一款非常优秀的开源 Windows 终端模拟器，完全可以代替 Windows 自带的 cmd 工具，可以在 <a href="https://cmder.net/">cmder 官网</a>下载。  </p>
<p>通过快捷键 <code>Ctrl + Shift + P</code> 打开 VSCode 的命令面板，搜索”open settings”，修改 VSCode 的配置文件。  </p>
<p><img src="https://gitee.com/kysonlok/imgurl/raw/master/img/20200611222134.jpg" alt="">  </p>
<p>在 json 配置文件中添加以下内容：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;terminal.integrated.shell.windows&quot;: &quot;cmd.exe&quot;,</span><br><span class="line">&quot;terminal.integrated.env.windows&quot;: &#123;</span><br><span class="line">    &quot;CMDER_ROOT&quot;: &quot;$cmder_root_path&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;terminal.integrated.shellArgs.windows&quot;: [</span><br><span class="line">    &quot;&#x2F;k&quot;,</span><br><span class="line">    &quot;$cmder_root_path&#x2F;vendor&#x2F;init.bat&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>将 <code>$cmder_root_path</code> 替换成 cmder 所在的根路径，注意左反斜杠路径要加转义，即 <code>\\</code>，或者直接使用右反斜杠 <code>/</code>，与 Linux 风格保持一致。<strong>路径不能包含空格，否则无法正常工作</strong>。  </p>
<p>重启 VSCode 生效，按 <code>Ctrl + `</code> 快捷键，就能在 VSCode 中的命令行窗口打开 cmder。  </p>
<p><img src="https://gitee.com/kysonlok/imgurl/raw/master/img/20200611223005.jpg" alt="">  </p>
<h2 id="WSL-远程"><a href="#WSL-远程" class="headerlink" title="WSL 远程"></a>WSL 远程</h2><p>WSL(Windows Subsystem for Linux) 是一款在 Windows10 系统下的 Linux 子系统，就是能在直接在 Windows10 上跑 Linux，不需要安装虚拟机。具体可以参考微软关于 <a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10">WSL 安装</a>的文档。   </p>
<p>开发一般用到 Linux 环境，但是开启虚拟机电脑又会变卡，选择 WSL 是很好的解决方案，主要的优势就是快，而且方便。  </p>
<p>VSCode 可以直接远程到 WSL，直接操作 WSL 的目录以及文件。需要安装 <code>Remote - WSL</code> 插件，在插件页面搜索安装即可。安装完成之后，按 <code>Ctrl + Shift + P</code> 快捷键打开命令面板，选择 <code>Remote-WSL: New Window</code> 就能远程到 WSL。  </p>
<blockquote>
<p>注意，WSL 远程的插件与本地插件是不能共用的，如果需要用到其他插件，要在插件页面安装到 WSL 上。  </p>
</blockquote>
<h2 id="SSH-远程"><a href="#SSH-远程" class="headerlink" title="SSH 远程"></a>SSH 远程</h2><p>WSL 基本能满足大部分的场景，但是特殊情况，比如嵌入式开发，用到交叉编译工具编译，WSL 是不支持交叉编译的。对于这种情况，我们会选择虚拟机或者服务器，以服务器为例，一般是没有图像界面的，VSCode 的 SSH 远程插件能远程到服务器，直接操作服务器下的目录以及文件。需要安装 <code>Remote - SSH</code> 插件，在插件页面搜索安装即可，跟 <code>Remote - WSL</code> 类似。  </p>
<p>需要说明的是，SSH 每次都要输入密码比较麻烦，可以使用公私钥免密码登录。  </p>
<p>首先，在 cmder 执行命令 <code>ssh-keygen</code> 生成公私钥对，提示输入密码时不设置密码，也就是直接回车。  </p>
<p>其次，用编辑器打开公钥文件 <code>id_rsa.pub</code>，复制全部内容。  </p>
<p>接着，ssh 远程登录到服务器，把公钥文件的内容粘贴到 <code>~/.ssh/authorized_keys</code> 文件中。  </p>
<p>最后，用 VSCode 远程到服务器，按 <code>Ctrl + Shift + P</code> 快捷键打开命令面板，选择 <code>Remote-SSH: Connect to Host</code>，在弹出的 ssh 连接框输入 <code>ssh -i [私钥的绝对路径] yourname@remote_host</code>。  </p>
<p><img src="https://gitee.com/kysonlok/imgurl/raw/master/img/20200612060820.jpg" alt="">  </p>
<p>再次选择 <code>Remote-SSH: Connect to Host</code> 就可以看到刚才添加的远程主机。  </p>
<p><img src="https://gitee.com/kysonlok/imgurl/raw/master/img/20200612061244.png" alt="">  </p>
<p>第一次连接 VSCode 可能不能自动检测到远程的系统类型，会弹框让我们手动选择，选择正确的系统类型，就能开始使用了，就像在本地使用 VSCode 那样，非常方便。  </p>
<blockquote>
<p>注意，远程主机的插件与本地插件是不能共用的，如果需要用到其他插件，要在插件页面安装到远程主机上。  </p>
</blockquote>
<h2 id="Markdown-预览增强"><a href="#Markdown-预览增强" class="headerlink" title="Markdown 预览增强"></a>Markdown 预览增强</h2><p>VSCode 默认支持 Markdown 预览，快捷键是 <code>Ctrl + Shift + V</code>，或者在命令面板面板运行 <code>Markdown: Open Preview to the Side</code>。  </p>
<p>但是自带的 Markdown 功能不是很强大，不支持 Latex 数学公式渲染，可以安装 <code>Markdown Preview Enhanced</code> 插件增强 Markdown 预览功能。  </p>
<h2 id="C-C-开发"><a href="#C-C-开发" class="headerlink" title="C/C++ 开发"></a>C/C++ 开发</h2><p>一般开发环境是 Linux，这里使用 VSCode ssh 远程到 Linux 目标主机的模式。远程到目标主机后，安装 <code>C/C++</code> 插件，并且在目标主机上安装 gcc 和 make 等开发工具。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install build-essential gdb make</span><br></pre></td></tr></table></figure>

<p>打开一个 C/C++ 工程，或者新创建一个工程，用 Makefile 构建好编译规则，配置 VSCode。  </p>
<h3 id="编译配置"><a href="#编译配置" class="headerlink" title="编译配置"></a>编译配置</h3><p>在菜单栏选择 <strong>Terminal &gt; Configure Default Build Task</strong>，下拉列表显示 c++ 编译器的各种预定义构建任务，选择 <code>C/C++: g++ build active file</code>，会自动在工程目录下生成 <code>.code/tasks.json</code> 配置文件。参考以下内容修改 tasks.json 配置：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; See https:&#x2F;&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?LinkId&#x3D;733558 </span><br><span class="line">    &#x2F;&#x2F; for the documentation about the tasks.json format</span><br><span class="line">    &quot;version&quot;: &quot;2.0.0&quot;,</span><br><span class="line">    &quot;tasks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;shell&quot;,</span><br><span class="line">            &quot;label&quot;: &quot;Make Project&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;&#x2F;usr&#x2F;bin&#x2F;make&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line">                &quot;-C&quot;,</span><br><span class="line">                &quot;$&#123;fileDirname&#125;&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;options&quot;: &#123;</span><br><span class="line">                &quot;cwd&quot;: &quot;&#x2F;usr&#x2F;bin&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;problemMatcher&quot;: [</span><br><span class="line">                &quot;$gcc&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;group&quot;: &#123;</span><br><span class="line">                &quot;kind&quot;: &quot;build&quot;,</span><br><span class="line">                &quot;isDefault&quot;: true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调试配置"><a href="#调试配置" class="headerlink" title="调试配置"></a>调试配置</h3><p>在菜单栏选择 <strong>Run &gt; Add Configuration…</strong>，下拉列表显示 gdb 调试器的各种预定义构建任务，选择 <code>C++ (GDB/LLDB)</code>，会自动在工程目录下生成 <code>.code/launch.json</code> 配置文件。参考以下内容修改 launch.json 配置：   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Use IntelliSense to learn about possible attributes.</span><br><span class="line">    &#x2F;&#x2F; Hover to view descriptions of existing attributes.</span><br><span class="line">    &#x2F;&#x2F; For more information, visit: https:&#x2F;&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?linkid&#x3D;830387</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;gcc build and debug active file&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;cppdbg&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;program&quot;: &quot;$&#123;fileDirname&#125;&#x2F;$&#123;fileBasenameNoExtension&#125;&quot;,</span><br><span class="line">            &quot;args&quot;: [],</span><br><span class="line">            &quot;stopAtEntry&quot;: false,</span><br><span class="line">            &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,</span><br><span class="line">            &quot;environment&quot;: [],</span><br><span class="line">            &quot;externalConsole&quot;: false,</span><br><span class="line">            &quot;MIMode&quot;: &quot;gdb&quot;,</span><br><span class="line">            &quot;setupCommands&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,</span><br><span class="line">                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,</span><br><span class="line">                    &quot;ignoreFailures&quot;: true</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;preLaunchTask&quot;: &quot;Make Project&quot;,</span><br><span class="line">            &quot;miDebuggerPath&quot;: &quot;&#x2F;usr&#x2F;bin&#x2F;gdb&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>preLaunchTask</code> 填的是 tasks.json 的 label 值，表示在调试之前先执行编译任务。  </p>
<p>更详细的指南，参考 VSCode 官方文档 <a href="https://code.visualstudio.com/docs/cpp/config-linux">GCC on Linux</a> 和 <a href="https://code.visualstudio.com/docs/cpp/cpp-debug">Debug C++ in Visual Studio Code</a>。  </p>
<h2 id="快捷键冲突"><a href="#快捷键冲突" class="headerlink" title="快捷键冲突"></a>快捷键冲突</h2><p><code>Ctrl + `</code>: 是 VSCode 打开命令行终端的快捷键，该快捷键会跟 cmder 的快捷键冲突，修改 cmder 的快捷键。  </p>
<p><img src="https://gitee.com/kysonlok/imgurl/raw/master/img/20200611215830.jpg" alt="">  </p>
<p><code>Ctrl + Shift + F</code>: 是 VSCode 打开搜索面板的快捷键，该快捷键会跟搜狗输入法的快捷键冲突，修改搜狗输入法的快捷键。  </p>
<p><img src="https://gitee.com/kysonlok/imgurl/raw/master/img/20200611220239.jpg" alt="">  </p>
<p><code>Ctrl + Shift + P</code>: 是 VSCode 打开命令面板的快捷键，该快捷键会跟 PicGo 图床工具的快捷键冲突，将其关闭。  </p>
<p><img src="https://gitee.com/kysonlok/imgurl/raw/master/img/20200611221755.jpg" alt="">  </p>
]]></content>
      <categories>
        <category>办公利器</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title>数据加密标准-DES</title>
    <url>/2020/06/12/%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86-DES/</url>
    <content><![CDATA[<h2 id="DES-加密概述"><a href="#DES-加密概述" class="headerlink" title="DES 加密概述"></a>DES 加密概述</h2><p>数据加密标准（Data Encryption Standard，缩写为 DES）是由国家标准局（NIST）出版的对称密钥分组密码（块密码）。  </p>
<p>对于任何加密体制，总有<strong>明文</strong>和<strong>密钥</strong>两个输入。DES 是费斯妥密码（Feistel Cipher）的一种实现，进行 16 轮迭代，其明文长度为 64 bit，密钥长度也是 64 bit（但只有 56 bit 被实际用于算法，其余 8 bit 可以被用于奇偶校验，并在算法中被丢弃）。  </p>
<a id="more"></a>  

<p>DES 的一般结构如下图所示，可见明文的处理经过了三个阶段。  </p>
<ol>
<li>首先，64 bit 明文经过<strong>初始置换(IP)</strong>而被重新排序；  </li>
<li>然后，经过 16 轮相同的<strong>费斯妥函数</strong>的处理过程，每轮包含了代替和置换两个步骤；  </li>
<li>最后， 再进行一次<strong>与初始置换互逆的置换($IP^{-1}$)</strong> ，得到 64 bit的密文。  </li>
</ol>
<p>除了初始和末尾的置换，DES 的结构与费斯妥密码结构完全相同。  </p>
<p><img src="https://gitee.com/kysonlok/imgurl/raw/master/img/20200612212511.jpg" alt=""></p>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><h3 id="初始置换和末尾置换"><a href="#初始置换和末尾置换" class="headerlink" title="初始置换和末尾置换"></a>初始置换和末尾置换</h3><p>初始置换和末尾置换只是对输入按位重新组合，在 DES 中没有密码学意义，初始置换和末尾置换如下所示： </p>
<p><img src="https://gitee.com/kysonlok/imgurl/raw/master/img/20200612212534.jpg" alt=""></p>
<p>输入的第 58 位换到第 1 位，第 50 位换到第2位，…，依此类推，最后一位是原来的第 7 位。假设输入的 64 位块为$M_1, M_2, M_3, …, M_{64}$，则经过初始置换后的结果为 $M_{58}, M_{50}, M_{42}, …, M_7$。  </p>
<p>64 位的输入 M：    </p>
<p><img src="https://gitee.com/kysonlok/imgurl/raw/master/img/20200612212550.jpg" alt=""></p>
<p>这里 $M_i$ 都是二进制，经过置换 X=IP(M) 之后，得到的 X：  </p>
<p><img src="https://gitee.com/kysonlok/imgurl/raw/master/img/20200612212612.jpg" alt=""></p>
<h3 id="费斯妥函数（F-函数）"><a href="#费斯妥函数（F-函数）" class="headerlink" title="费斯妥函数（F 函数）"></a>费斯妥函数（F 函数）</h3><p>DES 加密的核心是费斯妥函数，即每轮的变换。由费斯妥密码结构可知，明文会被均分成两等分，右半部分和密钥经过费斯妥函数处理。对于 DES 加密，48 bit 子密钥（由主密钥派生）和 32 bit 右半块作为费斯妥函数的输入，处理后输出 32 bit结果。  </p>
<p>下图是费斯妥函数的内部结构。密钥 $K_i$ 长度为 48 bit，R 长度为 32 bit。分为四个步骤：  </p>
<ol>
<li>将 R <strong>置换扩展</strong>为 48 bit，其中有 16 bit 是重复；  </li>
<li>置换扩展产生的 48 bit 输出与 48 bit 的 $K_i$ 异或；  </li>
<li>异或的结果经过“S盒”（置换盒），产生 32 bit 的输出；  </li>
<li>“S盒”的输出最后再经过一次 P 置换，得到的 32 bit 是费斯妥函数的输出。  </li>
</ol>
<p><img src="https://gitee.com/kysonlok/imgurl/raw/master/img/20200612212630.jpg" alt=""></p>
<h4 id="扩展置换"><a href="#扩展置换" class="headerlink" title="扩展置换"></a>扩展置换</h4><p>因为右半块长度是 32 bit，而密钥长度是 48 bit，因此，需要先把右半块扩展到 48 bit，称为“扩展置换”。扩展置换是将输入的 32 bit 半块分成 8 个 4 bit 小块，每 4 bit 块加上左右相邻块中紧邻的位，得到 6 bit 输出。第 1 块没有左邻，用第 32 位，最后一块没有右邻，用第 1 位。扩展置换输出 8 个 6 bit 的块，其逻辑如下：  </p>
<p><img src="https://gitee.com/kysonlok/imgurl/raw/master/img/20200612212651.jpg" alt=""></p>
<p>扩展置换逻辑通常被描述为下图的 DES 规范表格：  </p>
<p><img src="https://gitee.com/kysonlok/imgurl/raw/master/img/20200612212704.jpg" alt=""></p>
<h4 id="与密钥混合"><a href="#与密钥混合" class="headerlink" title="与密钥混合"></a>与密钥混合</h4><p>用异或操作将扩展的 48 bit 右半块和一个 48 bit 子密钥进行混合。16 轮变换使用 16 个 48 bit 子密钥，也就是每轮用的子密钥都是不同的，48 bit 的子密钥是利用密钥调度（下面介绍）从 58 bit 主密钥生成。    </p>
<h4 id="S-盒（置换盒）"><a href="#S-盒（置换盒）" class="headerlink" title="S 盒（置换盒）"></a>S 盒（置换盒）</h4><p>48 bit 的异或输出再经过 S 盒处理，产生 32 bit 的输出。S 盒执行真正的混淆，它提供了 DES 的核心安全性。如果没有 S 盒，密码会是线性的，很容易破解。DES 使用 8 个 S 盒，每个盒子以查找表方式提供非线性的变换，将 6 bit 输入变成 4 bit 输出。  </p>
<p><img src="https://gitee.com/kysonlok/imgurl/raw/master/img/20200612212723.jpg" alt=""></p>
<p>S 盒是一个 4x16 的表，盒 $S_i$ 输入的 6 bit 中，由第 1 位和第 6 位组成的二进制数确定表的行，中间 4 位组成的二进制数确定表的列，行和列交叉的元素转换成 4 bit 二进制数作为输出。  </p>
<p><img src="https://gitee.com/kysonlok/imgurl/raw/master/img/20200612212742.jpg" alt=""></p>
<p>DES 的 8 个 S 盒变换表（下标从 0 开始）规格如图所示：  </p>
<p><img src="https://gitee.com/kysonlok/imgurl/raw/master/img/20200612212804.jpg" alt=""></p>
<p>例如，在 $S_1$ 中，若输入为 011001，则行是 1(01)，列是 12(1100)，由行和列确定的元素是 9(1, 12)，9 对应的二进制为 1001，因此 4 bit 输出为 1001。  </p>
<h4 id="置换"><a href="#置换" class="headerlink" title="置换"></a>置换</h4><p>S 盒的 32 bit 输出最后再经过一次“P置换”进行重组。这个设计是为了将每个 S 盒的 4 位输出在下一回次的扩张后，使用 4 个不同的 S 盒进行处理。置换表格如下图所示：  </p>
<p><img src="https://gitee.com/kysonlok/imgurl/raw/master/img/20200612212839.jpg" alt=""></p>
<p>S 盒，P 置换和 E 扩展各自满足了克劳德·香农在 1940 年代提出的实用密码所需的必要条件——“混淆与扩散”。  </p>
<h3 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h3><p>前面我们知道，密钥长度为 64 bit，算法只用 56 bit。循环密钥生成器从 56 bit 密钥中创建 16 个 48 bit 子密钥。密钥生成过程如下图所示。  </p>
<p><img src="https://gitee.com/kysonlok/imgurl/raw/master/img/20200612212856.jpg" alt=""></p>
<p>首先，使用选择置换 1(PC-1) 从 64 bit 输入密钥中选出 56 bit 的密钥，剩余的 8 bit 要么直接被丢弃掉，要么作为奇偶校验位。  </p>
<p>然后，将 56 bit 密钥分成两个 28 bit 的半密钥。在接下来的每轮变换中，两个半密钥都被左移 1 或 2 位（左移 1 还是 2 由当前的迭代轮数决定），移位后的值作为下一轮的输入，并且通过选择置换 2(PC-2) 压缩成 48 bit 的子密钥。  </p>
<p>解密过程中，除了子密钥输出的顺序相反外，密钥调度的过程与加密完全相同。  </p>
<p>置换选择以及移位次数如下图所示：  </p>
<p><img src="https://gitee.com/kysonlok/imgurl/raw/master/img/20200612212925.jpg" alt=""></p>
<h2 id="安全与密码分析"><a href="#安全与密码分析" class="headerlink" title="安全与密码分析"></a>安全与密码分析</h2><p>DES 满足分组密码的两个要求，这两个特性使加密非常强大。  </p>
<ul>
<li><p>雪崩效应——明文或密钥的微小改变将对密文产生很大的影响。  </p>
</li>
<li><p>完备性——每一位密文都依赖于许多位明文。  </p>
</li>
</ul>
<p>到当前为止，最实用的攻击方法仍然是暴力攻击。虽然有 3 种理论攻击（差分密码分析、线性密码分析和改进的戴维斯攻击）的理论复杂性小于暴力破解，但需要不现实的已知明文或选择明文数量，并无实用价值。  </p>
<p>DES 已被证明是一种设计良好的分组密码。除了暴力穷举密钥搜索外，DES 没有受到任何重要的密码分析攻击。为抵抗暴力破解，有大量的 DES 的代替算法，最重要的有 AES 和 3DES。  </p>
]]></content>
      <categories>
        <category>密码学与安全</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
</search>
